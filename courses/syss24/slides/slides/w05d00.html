<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>free</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="https://cd-public.github.io/slides/html_srcs/reveal.js/dist/reset.css">
  <link rel="stylesheet" href="https://cd-public.github.io/slides/html_srcs/reveal.js/dist/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="https://cd-public.github.io/slides/html_srcs/reveal.js/dist/theme/sky.css" id="theme">
  <link rel="stylesheet" href="https://cd-public.github.io/slides/html_srcs/reveal.js/plugin/highlight/monokai.css">
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section>
<br><br><br>
  <h1 style="font-family: monospace;text-transform: lowercase;">free</h1>
  <h2>CS 271</h2>
  <h2>Prof. Calvin</h2>
  <h2>19 Feb 24</h2>
  <h2>w05d00</h2>
</section>
<section>
<h2>Announcements</h2>
<ul>
<li>Realistically, malloc part 2... &lt;spooky&gt;
<li>Recall: UNC REU due 25 Feb
<li>Recall: Garmin trip on March 14
<li>HW1: Buddhabrot
<ul><li>is available to consider
<li>technically possible
<li>but not due until 3/04 (two weeks post all-of-malloc)
</section>
<section>
<h2>Today</h2>
<dl>
<dt>Malloc part 2</dt>
<dd>free()
</dd>
<dd>
</dd>
<dt>Memory-adjacent tech</dt>
<dd>casting</dd>
<dd>pointer arithmetic</dd>
<dd>unary &</dd>
</dl>
</section>
<section>
<h2>Finger Binary</h2>
<p>I am going to ask review questions and would like you to show your answer using "finger binary".</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: center;"><img width="70%" src="https://www.convertbinary.com/wp-content/uploads/closed-fist-0.png"><br>0b00 == 0</td>
<td style="text-align: center;"><img width="70%" src="https://www.convertbinary.com/wp-content/uploads/thumb-raised1.png"><br>0b01 == 1</td>
</tr>
<tr class="even">
<td style="text-align: center;"><img width="70%" src="https://www.convertbinary.com/wp-content/uploads/indexraised2.png"><br>0b10 == 2</td>
<td style="text-align: center;"><img width="70%" src="https://www.convertbinary.com/wp-content/uploads/3.png"><br>0b11 == 3</td>
</tr>
</tbody>
</table>
</section>
<section>
<h2>Review Question</h2>
<div style="outline-style:double;background-color:cyan">
<p>What is the return type of malloc()?</p>
<div >
<ol start="0">
<li style="padding-bottom: .3em;"><code>size_t</code></li>
<li style="padding-bottom: .3em;"><code>unsigned long int</code></li>
<li style="padding-bottom: .3em;"><code>void</code></li>
<li style="padding-bottom: .3em;"><code>void *</code></li>
</ol>
</div>
</section>
<section>
<h2>Review Question</h2>
<div style="outline-style:double;background-color:cyan">
<p>What is the type of given by a sizeof()?</p>
<div>
<ol start="0">
<li style="padding-bottom: .3em;"><code>size_t</code></li>
<li style="padding-bottom: .3em;"><code>unsigned long int</code></li>
<li style="padding-bottom: .3em;"><code>void</code></li>
<li style="padding-bottom: .3em;"><code>void *</code></li>
</ol>
</div>
</section>
<section>
<h2>Review Question</h2>
<div style="outline-style:double;background-color:cyan">
<p>What is the type of the malloc's one argument?</p>
<div>
<ol start="0">
<li style="padding-bottom: .3em;"><code>size_t</code></li>
<li style="padding-bottom: .3em;"><code>unsigned long int</code></li>
<li style="padding-bottom: .3em;"><code>void</code></li>
<li style="padding-bottom: .3em;"><code>void *</code></li>
</ol>
</div>
</section>
<section>
<h2>Review Question</h2>
<div style="outline-style:double;background-color:cyan">
<p>While sizes vary by system, what bit size do we commonly find size_t to be?<br>(using base 10 on this slide)</p>
<div>
<ol start="0">
<li style="padding-bottom: .3em;"><code>01 byte  = 08 bits</code></li>
<li style="padding-bottom: .3em;"><code>02 bytes = 16 bits</code></li>
<li style="padding-bottom: .3em;"><code>04 bytes = 32 bits</code></li>
<li style="padding-bottom: .3em;"><code>08 bytes = 64 bits</code></li>
</ol>
</div>
</section>
<section>
<h2>Review Question</h2>
<div style="outline-style:double;background-color:cyan">
<p>While sizes vary by system, what bit size do we commonly find void * to be?<br>(using base 10 on this slide)</p>
<div>
<ol start="0">
<li style="padding-bottom: .3em;"><code>01 byte  = 08 bits</code></li>
<li style="padding-bottom: .3em;"><code>02 bytes = 16 bits</code></li>
<li style="padding-bottom: .3em;"><code>04 bytes = 32 bits</code></li>
<li style="padding-bottom: .3em;"><code>08 bytes = 64 bits</code></li>
</ol>
</div>
</section>
<section>
<h2>Review Question</h2>
<div style="outline-style:double;background-color:cyan">
<p>A void * of size 8 (bytes) can store approximately how many distinct values?<br>(using base 10 on this slide)</p>
<div>
<ol start="0">
<li style="padding-bottom: .3em;"><code>~10^09 ~=     billions</code></li>
<li style="padding-bottom: .3em;"><code>~10^12 ~=    trillions</code></li>
<li style="padding-bottom: .3em;"><code>~10^15 ~= quadrillions</code></li>
<li style="padding-bottom: .3em;"><code>~10^18 ~= quintillions</code></li>
</ol>
</div>
</section>
<section>
<h2>Review</h2>
<ul>
<li>Imagine mallocing all of memory in a single call.
<ul><li>malloc(0xFF...) will either crash or return a void * of zero (since that is the only place to start a memory region that large).</ul>
<li>Imagine mallocing all of memory into one byte size pieces.
<ul><li>This would return 0xFF... void *s, the largest of which would be 0xFF...</ul>
<li>void * and size_t range from the same minimum (0) to maximum (0xFF...) size, so they are the same bit size.
<code>#include &lt;stdlib.h&gt; // for size_t
#include &lt;assert.h&gt; // for assert

int main()
{
    assert(sizeof(void *) == sizeof(size_t)) ; // assertion passes
    assert(sizeof(char) == 1) ;                // assertion passes
    assert(1 == 0) ;                           // assertion fails
    return 0;
}</code>
<p>Read more on assert <a href="https://web.archive.org/web/20090707025230/http://www.ddj.com/blog/cppblog/archives/2007/07/assertions_vers.html">here</a> (or don't).
</section>
<section><ul><a href="https://man7.org/linux/man-pages/man3/malloc.3.html">
<code>NAME         top

       malloc, free, - allocate and free dynamic memory

LIBRARY         top

       Standard C library (libc, -lc)

SYNOPSIS         top

       #include <stdlib.h>

       void *malloc(size_t size);
       void free(void *_Nullable ptr);

DESCRIPTION         top

   malloc()
       The malloc() function allocates size bytes and returns a pointer
       to the allocated memory.  The memory is not initialized.  If size
       is 0, then malloc() returns a unique pointer value that can later
       be successfully passed to free().</code></a>
</section>
<section>
<h2><code>malloc</code></h2>
<ul>
<li>But where does the memory come from?
<li>So far, "the stack" - a memory regime vaguely related to the data structure
<li>For malloc, "the heap" - a memory regime even more vaguely related to the data structure 
<li>Stack and heap exist in different regions of system memory, so stack memory is near stack memory but distant from heap memory.
<code>char arr0[256], arr1[256], arr2[256] ;
char *ptr0 = malloc(256), *ptr1 = malloc(256), *ptr2 = malloc(256) ;
printf("%p\n%p\n%p\n%p\n%p\n%p\n", arr0, arr1, arr2, ptr0, ptr1, ptr2) ;</code>
<li>How far are all these things apart from each other:
<code>0x7ffdcfaae0c0
0x7ffdcfaae1c0
0x7ffdcfaae2c0
0x556f982022a0
0x556f982023b0
0x556f982024c0</code>
</ul>
</section>
<section>
<h2>Heap Example</h2>
<table>
<colgroup>
<col style="width: 35%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="header">
<th style="font-weight:normal"><div><ol style="vertical-align: top">
    <li>Three operations. 
	<ul><li>Stack-allocate sizeof(int *) bytes for <span style="color:darkred;font-family:courier">p</span> for <span style="color:darkred;font-family:courier">main</span>.
	<li>Heap-allocate sizeof(int) bytes
	<li>Store the memory location of the heap allocated bytes in <span style="color:darkred;font-family:courier">p</span>.<ul><li>As a reference, we denote this with an arrow rather than by showing a value.
	<li>The "value" stored is the same value seen by <span style="font-family:courier">printf("%p",p);</span>
</th>
<th style="text-align: center;font-weight:normal"><img width="1620" style="vertical-align: top" src="../images/heap_demo_0.png"></th>
</tr>
</thead>
</table>
</section>
<section>
<h2>Heap Example</h2>
<table>
<colgroup>
<col style="width: 35%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="header">
<th style="font-weight:normal"><div><ol style="vertical-align: top">
    <li>Three operations. 
	<ul><li>Stack-allocate <span style="color:darkred;font-family:courier">p</span> for <span style="color:darkred;font-family:courier">main</span>.
	<li>Heap-allocate sizeof(int) bytes
	<li>Store the heap location in <span style="color:darkred;font-family:courier">p</span>.
</th>
<th style="text-align: center;font-weight:normal"><img width="1620" style="vertical-align: top" src="../images/heap_demo_0.png"></th>
</tr>
</thead>
</table>
</section>

<section>
<h2>Heap Example</h2>
<table>
<colgroup>
<col style="width: 35%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="header">
<th style="font-weight:normal"><div><ol style="vertical-align: top">
    <li>Three operations. 
	<ul><li>Stack-allocate <span style="color:darkred;font-family:courier">p</span> for <span style="color:darkred;font-family:courier">main</span>.
	<li>Heap-allocate sizeof(int) bytes
	<li>Store the heap location in <span style="color:darkred;font-family:courier">p</span>.</ul>
	<li>Store <span style="color:darkred;font-family:courier">0</span> at the heap location <span style="color:darkred;font-family:courier">p</span> references.
</th>
<th style="text-align: center;font-weight:normal"><img width="1620" style="vertical-align: top" src="../images/heap_demo_1.png"></th>
</tr>
</thead>
</table>
</section>

<section>
<h2>Heap Example</h2>
<table>
<colgroup>
<col style="width: 35%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="header">
<th style="font-weight:normal"><div><ol style="vertical-align: top">
    <li>Three operations. 
	<ul><li>Stack-allocate <span style="color:darkred;font-family:courier">p</span> for <span style="color:darkred;font-family:courier">main</span>.
	<li>Heap-allocate sizeof(int) bytes
	<li>Store the heap location in <span style="color:darkred;font-family:courier">p</span>.</ul>
	<li>Store <span style="color:darkred;font-family:courier">0</span> at the heap location <span style="color:darkred;font-family:courier">p</span> references.
    <li>Three operations. 
	<ul><li>Stack-allocate <span style="color:darkred;font-family:courier">q</span> for <span style="color:darkred;font-family:courier">main</span>.
	<li>Heap-allocate 2 * sizeof(int) bytes
	<li>Store the heap location in <span style="color:darkred;font-family:courier">q</span>.</ul>
</th>
<th style="text-align: center;font-weight:normal"><img width="1620" style="vertical-align: top" src="../images/heap_demo_2.png"></th>
</tr>
</thead>
</table>
</section>

<section>
<h2>Heap Example</h2>
<table>
<colgroup>
<col style="width: 35%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="header">
<th style="font-weight:normal"><div><ol style="vertical-align: top">
    <li>Three operations. 
	<ul><li>Stack-allocate <span style="color:darkred;font-family:courier">p</span> for <span style="color:darkred;font-family:courier">main</span>.
	<li>Heap-allocate sizeof(int) bytes
	<li>Store the heap location in <span style="color:darkred;font-family:courier">p</span>.</ul>
	<li>Store <span style="color:darkred;font-family:courier">0</span> at the heap location <span style="color:darkred;font-family:courier">p</span> references.
    <li>Three operations. 
	<ul><li>Stack-allocate <span style="color:darkred;font-family:courier">q</span> for <span style="color:darkred;font-family:courier">main</span>.
	<li>Heap-allocate 2 * sizeof(int) bytes
	<li>Store the heap location in <span style="color:darkred;font-family:courier">q</span>.</ul>
	<li>Store <span style="color:darkred;font-family:courier">1</span> at the heap location <span style="color:darkred;font-family:courier">q</span> references.
</th>
<th style="text-align: center;font-weight:normal"><img width="1620" style="vertical-align: top" src="../images/heap_demo_3.png"></th>
</tr>
</thead>
</table>
</section>

<section>
<h2>Heap Example</h2>
<table>
<colgroup>
<col style="width: 35%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="header">
<th style="font-weight:normal"><div><ol style="vertical-align: top">
    <li>Three operations. 
	<ul><li>Stack-allocate <span style="color:darkred;font-family:courier">p</span> for <span style="color:darkred;font-family:courier">main</span>.
	<li>Heap-allocate sizeof(int) bytes
	<li>Store the heap location in <span style="color:darkred;font-family:courier">p</span>.</ul>
	<li>Store <span style="color:darkred;font-family:courier">0</span> at the heap location <span style="color:darkred;font-family:courier">p</span> references.
    <li>Three operations. 
	<ul><li>Stack-allocate <span style="color:darkred;font-family:courier">q</span> for <span style="color:darkred;font-family:courier">main</span>.
	<li>Heap-allocate 2 * sizeof(int) bytes
	<li>Store the heap location in <span style="color:darkred;font-family:courier">q</span>.</ul>
	<li>Store <span style="color:darkred;font-family:courier">1</span> at the heap location <span style="color:darkred;font-family:courier">q</span> references.
	<li>Store <span style="color:darkred;font-family:courier">2</span> at the heap location immediately following <span style="color:darkred;font-family:courier">q</span>.
	<ul><li>Lot going on here. We'll discuss this latter as "pointer arithmetic", a "C bad" discussion.
</th>
<th style="text-align: center;font-weight:normal"><img width="1620" style="vertical-align: top" src="../images/heap_demo_4.png"></th>
</tr>
</thead>
</table>
</section>

<section>
<h2>Heap Example</h2>
<table>
<colgroup>
<col style="width: 35%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="header">
<th style="font-weight:normal"><div><ol style="vertical-align: top">
    <li>Three operations. 
	<ul><li>Stack-allocate <span style="color:darkred;font-family:courier">p</span> for <span style="color:darkred;font-family:courier">main</span>.
	<li>Heap-allocate sizeof(int) bytes
	<li>Store the heap location in <span style="color:darkred;font-family:courier">p</span>.</ul>
	<li>Store <span style="color:darkred;font-family:courier">0</span> at the heap location <span style="color:darkred;font-family:courier">p</span> references.
    <li>Three operations. 
	<ul><li>Stack-allocate <span style="color:darkred;font-family:courier">q</span> for <span style="color:darkred;font-family:courier">main</span>.
	<li>Heap-allocate 2 * sizeof(int) bytes
	<li>Store the heap location in <span style="color:darkred;font-family:courier">q</span>.</ul>
	<li>Store <span style="color:darkred;font-family:courier">1</span> at the heap location <span style="color:darkred;font-family:courier">q</span> references.
	<li>Store <span style="color:darkred;font-family:courier">2</span> at the heap location immediately following <span style="color:darkred;font-family:courier">q</span>.
	<li>Store the numerical value referring to heap location <span style="color:darkred;font-family:courier">q</span> in <span style="color:darkred;font-family:courier">p</span>.
</th>
<th style="text-align: center;font-weight:normal"><img width="1620" style="vertical-align: top" src="../images/heap_demo_5.png"></th>
</tr>
</thead>
</table>
</section>

<section>
<h2>Free</h2>
<ul><li><em>"We'll discuss this latter in the context of free() aka malloc part 2."</em> - me
<li>Latter is now!
<code>void free(void *_Nullable ptr);</code>
<br>
<code>   free()
       The free() function frees the memory space pointed to by ptr,
       which must have been returned by a previous call to malloc() or
       related functions.  Otherwise, or if ptr has already been freed,
       undefined behavior occurs.  If ptr is NULL, no operation is
       performed.</code>
</section>

<section>
<h2>Heap Allocation</h2>
<table>
<colgroup>
<col style="width: 35%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="header">
<th style="font-weight:normal"><div><ol style="vertical-align: top">
    <li><span style="color:darkred;font-family:courier">p</span> holds address of the heap location holding the integer value <span style="color:darkred;font-family:courier">0</span>.
	<li><span style="color:darkred;font-family:courier">q</span> holds address of the heap location holding the integer array value <span style="color:darkred;font-family:courier">1</span>.
	<ul><li>This is equivalent to holding location of the integer array <span style="color:darkred;font-family:courier">{ 1, 2 }</span> in this case.</ul>
	<li>Both <span style="color:darkred;font-family:courier">p</span> and <span style="color:darkred;font-family:courier">q</span> hold return values from a <span style="color:darkred;font-family:courier">malloc()</span> call.<ul>
	<li>We term this type of pointer a "*_Nullable".
	<li>All *_Nullable's are *'s, but not all *'s and *_Nullable's
	<li>{ <em>p</em> &in; *_Nullable } &sub; { <em>p</em> &in; * }</ul>
</th>
<th style="text-align: center;font-weight:normal"><img width="1620" style="vertical-align: top" src="../images/heap_demo_4.png"></th>
</tr>
</thead>
</table>
</section>

<section>
<h2>Heap Allocation</h2>
<table>
<colgroup>
<col style="width: 35%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="header">
<th style="font-weight:normal"><div><ol style="vertical-align: top">
    <li>As <span style="color:darkred;font-family:courier">p</span> is set to equal <span style="color:darkred;font-family:courier">q</span>, the original value in <span style="color:darkred;font-family:courier">p</span> is lost.
	<ul><li>The only place the return value of the first <span style="color:darkred;font-family:courier">malloc</span> call was stored was in <span style="color:darkred;font-family:courier">p</span>.
	<li>No other value was set equal to <span style="color:darkred;font-family:courier">p</span> before the value in <span style="color:darkred;font-family:courier">p</span> was altered.
	<li>There necessarily exists memory allocated to the program that the program has no clear way to reach.
	<li>We term this a "memory leak".

</th>
<th style="text-align: center;font-weight:normal"><img width="1620" style="vertical-align: top" src="../images/heap_demo_5.png"></th>
</tr>
</thead>
</table>
</section>

<section>
<h2>Memory leaks</h2>
<ul><li>A memory leak occurs when some memory is allocated for some program by malloc() and the address of this memory is lost to the allocating program.
<li>In the worst case, this may occur in loops.
<code>int main() // Leak 0xFFFF bytes of memory
{
	int i, *p, *q;
	for ( i = 0 ; i < 0xFFFF ; i++ )
	{
		p = malloc(sizeof(int)) ;
		q = malloc(sizeof(int) * 2) ;
		*p = i ;
		*q = i + 1 ;
		q[1] = i + 2;
		p = q ;
	}
	return 0 ;
}</code>
<li>I was unwilling to run this on my system but you can try it if you want. Modern OSes are pretty scrappy.
</section>

<section>
<h2>Memory leaks</h2>
<ul><li>Generally speaking, if you're computer/phone slows down over time then is faster again after a reboot, there is a memory leak driving this slowdown.
<li>Windows XP famously contained a number of memory leaks, and Microsoft now provides tooling and documentation on isolating memory leaks in their operating system:
<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/using-the-kernel-debugger-to-find-a-kernel-mode-memory-leak"><code>kd> !poolused 4 
Sorting by Paged Pool Consumed

Pool Used:
            NonPaged            Paged     
Tag    Allocs     Used    Allocs     Used 
Abc         0        0     36405 33930272 
Tron        0        0       552  7863232 
IoN7        0        0     10939   998432 
Gla5        1      128      2222   924352 
Ggb         0        0        22   828384 </code></a>
<li>I would assume the Linux kernel has at least one memory leak but I would never admit that in polite company.
<li>In practice, most memory leaks come from programs written by CS majors that slept through this class.
</section>

<section>
<h2>Memory leaks</h2>
<ul><li>A memory leak occurs when some memory is allocated for some program by malloc() and the address of this memory is lost to the allocating program.
<li>Free allows us to safely work with memory within code blocks (including loops) by deallocating unused memory.
<code>int main() // Leak 0xFFFF bytes of memory
{
	int i, *p, *q;
	for ( i = 0 ; i < 0xFFFF ; i++ )
	{
		p = malloc(sizeof(int)) ;
		q = malloc(sizeof(int) * 2) ;
		*p = i ;
		*q = i + 1 ;
		q[1] = i + 2;
		free(p) ; // Avert memory leak.
		p = q ;
	}
	return 0 ;
}</code>

</section>

<section>
<h2>Heap Allocation</h2>
<table>
<colgroup>
<col style="width: 35%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="header">
<th style="font-weight:normal"><div><ol style="vertical-align: top">
    <li><span style="color:darkred;font-family:courier">p</span> holds a *_Nullable.
	<li><span style="color:darkred;font-family:courier">q</span> holds a *_Nullable.
	
</th>
<th style="text-align: center;font-weight:normal"><img width="1620" style="vertical-align: top" src="../images/heap_demo_4.png"></th>
</tr>
</thead>
</table>
</section>

<section>
<h2>Heap Allocation</h2>
<table>
<colgroup>
<col style="width: 35%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="header">
<th style="font-weight:normal"><div><ol style="vertical-align: top">
    <li><span style="color:darkred;font-family:courier">p</span> holds a *_Nullable.
	<li><span style="color:darkred;font-family:courier">q</span> holds a *_Nullable.
	<li>Three operations. 
	<ul><li>Heap-deallocate the memory pointed to by <span style="color:darkred;font-family:courier">p</span>.<ul>
	<li>That is, someone else (the OS, another program, another malloc) can use the memory.</ul>
	<li>Mark the value in <span style="color:darkred;font-family:courier">p</span> as no longer defined.
	<ul><li>Looking at the value in this pointer <em>might</em> segfault.</ul>
	<li>Mark the value formerly pointed to by <span style="color:darkred;font-family:courier">p</span> as undefined.
	<ul><li>In practice, it likely stores the same value as before, but checking might segfault.
	
</th>
<th style="text-align: center;font-weight:normal"><img width="1620" style="vertical-align: top" src="../images/free_demo_5.png"></th>
</tr>
</thead>
</table>
</section>

<section>
<h2>Free + Leak = Freak</h2>
<ul><li>We can generate a silly outcome at high probability by:
<ol>
<li>Store value to heap
<li>Memory leak
<li>Check value</ol>
<code>long *p = malloc(sizeof(long)), *q , i ;
*p = 1 ;                          // safe
printf("%ld\n", *p) ;             // safe
free(p) ;
for ( i = 0 ; i < 1000000 ; i++) 
{ 
    q = malloc(0xFF) ; *q = i ;   // leak
}
printf("%ld\n", *p) ;             // unsafe</code>
<li>I got
<code>1
22923750333</code>
<li>Stream "Super Freaky Girl" by Nicki Minaj on Spotify (or don't)
</section>

<section>
<h2>Today</h2>
<dl>
<dt>✓ Malloc part 2</dt>
<dd>✓ free()
</dd>
<dd>
</dd>
<dt>Memory-adjacent tech</dt>
<dd>casting</dd>
<dd>pointer arithmetic</dd>
<dd>unary &</dd>
</dl>
</section>

<section>
<h2>Casting</h2>
<h4>When an unsigned long int portrays a void pointer in the school play <em>Der Ring des Nibelungen</em>.</h4>
<ul><li>A void *, a size_t, and a character array of length 8 walk into a compiler.
<ul><li>The compiler asks "Why the long int"?</ul>
<li>In running code, there is no distinction between any of these: each is simply 64 bits.
<li>The compiler maintains the distinction when generating code to make writing code easier for humans.
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Use</th>
<th style="text-align: left;">Print code</th>
<th style="text-align: left;">sizeof(), usually</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">void *<em>x</em></td>
<td style="text-align: left;">a memory location</td>
<td style="text-align: left;">%p</td>
<td style="text-align: left;">8</td>
</tr>
<tr class="even">
<td style="text-align: left;">size_t <em>x</em></td>
<td style="text-align: left;">size of a memory region</td>
<td style="text-align: left;">%zu or %ld</td>
<td style="text-align: left;">8</td>
</tr>
<tr class="odd">
<td style="text-align: left;">char <em>x</em>[8]</td>
<td style="text-align: left;">8 values of size 1, often null-terminated ascii values</td>
<td style="text-align: left;">%s</td>
<td style="text-align: left;">8</td>
</tr>
<tr class="even">
<td style="text-align: left;">long x ; long int y ;</td>
<td style="text-align: left;">numerical data of size up to 2^63 that may be negative</td>
<td style="text-align: left;">%ld</td>
<td style="text-align: left;">8</td>
</tr>
</tbody>
</table>
</section>

<section>
<h2>Casting</h2>
<ul>
<li>To cast, given a literal value or a variable, cast using a type name enclosed in parenthesis as a prefix operator.
<ul><li>In many cases, this helps with code clarity even when no compiler warning is drawn.
<code>char lil = (char)255 ; // 255 is larger than an unsigned char can hold
printf("%d\n", lil)  ; // prints "-1"</code>
<li>We can use casts to change pointers into values - this is usually a bad idea:
<code>char *str = "hi" ;
long val = (long)str ; // str is the numerical value of memory location
printf("%ld\n", val) ; // prints some large value in decimal</code>
<li>We can use casts to fill out more bits...
<code>val = (long)lil ;
printf("%lx\n", val) ; // prints 16 f's (-1)
val = (long)(unsigned char)lil ;
printf("%lx\n", val) ; // prints 2 f's (255)</code>
<li>Or cut bits off...
<code>val = 0xabc ;
lil = (char)val ;
printf("%hhx\n", val ) ; // prints "bc"</code>
</section>

<section>
<h2>Implicit Casting</h2>
<ul>
<li>The compiler can infer casts, but if they are sketchy will throw a warning:
<code>int main()
{
    void *ptr = 'h' ;
    return 0;
}</code>
<li>It is unlikely that this code was written as intended. GCC warns:
<code>hi.c: In function ‘main’:
hi.c:13:17: warning: initialization of ‘void *’ from ‘int’ makes pointer from integer without a cast [-Wint-conversion]
   13 |     void *ptr = 'h' ;
      |  </code>
<li>I think GCC could be more aggressive with signed vs unsigned values, but that's just me.
<li>This segfaults after compiling without any warnings. Fun!
<code>void *ptr = (void *)'h' ;
printf("%s", (char *)ptr ) ; // segfault</code>
</section>

<section>
<h2>Casting as Documentation</h2>
<ul>
<li>Sometimes we can use casts to make it more clear what our code should be doing.
<code>char *str = (char *)malloc(sizeof(char) * 8) ; // malloc returns void *</code>
<li>I like void casts, they remind me of Python "_ =" which I use in notebooks to discard output.
<code>(void)printf("%s\n", str) ; // printf returns an int - we don't care.</code>
<li>Sometimes, e.g. in textual analysis, we count characters...
<code>char *in = "loremipsum" ; // etc
unsigned counts[26] ; // what are the default values here btw
while (str[i++]) 
{
    counts[(size_t)(in[i] - 'a')]++ ; // use letter as index
}</code>
<li>Python is generally used for text analysis now, but C is still in use.
</section>

<section>
<h2>Casting</h2>
<ul>
<code>int main() {
	char   buf[8] = "hihi :)"   ; // we create a string
	long  *tmp    = (long *)buf ; // we say buf is the addr of a long
	long   num    = *tmp        ; // we say num is the value of stored at buf
	void  *ptr    = (void *)num ; // we say the value in num is, itself, an addr
	size_t siz    = (size_t)num ; // we say the value in num is a size
	printf("%s / %p / %zu / %ld\n", buf, ptr, siz, num ) ;
	for ( int i = 7 ; i > -1 ; i-- ) {
		printf("%02hhX", buf[i]) ;
	}
	printf(" / %016lx / %016lx / %016lx\n", 
	        (long unsigned)ptr, (long unsigned)siz, (long unsigned)num ) ;
	return 0 ;
}</code>
<br>
<code>user@DESKTOP-THMS2PJ:~$ gcc hi.c ; ./a.out
hihi :) / 0x293a2069686968 / 11604384926951784 / 11604384926951784
00293A2069686968 / 00293a2069686968 / 00293a2069686968 / 00293a2069686968
user@DESKTOP-THMS2PJ:~$ </code>
</section>

<section>
<h2>Takeaways</h2>
<ul><li>Cast the return value of malloc.
<code>int main() {
    char *ptr = malloc(8) ; // error-prone, ambigious
    char *str = (char *)malloc(sizeof(char) * 8) ; // more intentional
}</code>
<li>Much bigger deal when using types of size other than one, or of unknown size.
<br>
</section>

<section>
<h2>Today</h2>
<dl>
<dt>✓ Malloc part 2</dt>
<dd>✓ free()
</dd>
<dd>
</dd>
<dt>Memory-adjacent tech</dt>
<dd>✓ casting</dd>
<dd>pointer arithmetic</dd>
<dd>unary &</dd>
</dl>
</section>

<section>
<h2>Pointer Arithmetic</h2><table>
<colgroup>
<col style="width: 35%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="header">
<th style="font-weight:normal"><div><ul style="vertical-align: top">
    <li>Wait a minute... sizeof(int) != 1.
	<li>Whatever value <span style="color:darkred;font-family:courier">q</span> is must be some value other than <span style="color:darkred;font-family:courier">1</span> away from <span style="color:darkred;font-family:courier">q[1]</span>
	<li>Yet we do not address the next int in an array by saying <span style="color:darkred;font-family:courier">q[1*sizeof(int)]</span>
	<li>Recall:
	<ul><li>Lot going on here. We'll discuss this latter as "pointer arithmetic", a "C bad" discussion.
</th>
<th style="text-align: center;font-weight:normal"><img width="1620" style="vertical-align: top" src="../images/heap_demo_4.png"></th>
</tr>
</thead>
</table>
</section>

<section>
<h2>Recall: Python bad</h2>
<ul>
<li>People are allowed to like things, so you are allowed to like this.
<li>I don't.
<code>&gt;&gt;&gt; x, y, s, t = 1, 2, "h", "i"
&gt;&gt;&gt; x + y
3
&gt;&gt;&gt; x + s
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unsupported operand type(s) for +: 'int' and 'str'
&gt;&gt;&gt; s + t
'hi'
&gt;&gt;&gt;</code>
<li>This is called operator overloading. It's not allowed in C.
</section>

<section>
<h2>Recall: C Good</h2>
<ul>
<li>You honestly mean to tell me "one" + "two" should be "onetwo" and not "three"?
<li>If you try to add strings together, gcc tells you to to rethink your decisions.
<code>int main()
{
	char *str0 = "If thou dost appreciate/" ;
	char *str1 = "Then thine shalt place/" ;
	printf(str0 + str1) ;
	return 0 ;
}</code>
<li>Thanks, C.
<code>user@DESKTOP-THMS2PJ:~/dev/as_zagreb/271sp24/notes$ gcc test.c ; ./a.out
test.c: In function ‘main’:
test.c:16:17: error: invalid operands to binary + (have ‘char *’ and ‘char *’)
   16 |     printf(str0 + str1) ;
      |                 ^
user@DESKTOP-THMS2PJ:~/dev/as_zagreb/271sp24/notes$
</code>
<li>What does "binary" mean here? (Hint: MATH 251W)
</section>

<section>
<h2>C... Bad?</h2>
<ul>
<li>Okay but what about when we add 0x100 + 0x001.
<code>int main()
{
    long unsigned *p = (long unsigned *) 0x100 ;
    long unsigned  x = (long unsigned  ) 0x001 ;
    // With casting, %p expects "void *", so we cast to (void *)
    printf("%p + %p = %p\n", (void *)p, (void *)x, (void *)(p + x)) ;
    return 0;
}</code>
<li>This should be easy.
<code>user@DESKTOP-THMS2PJ:~$ gcc hi.c ; ./a.out
0x100 + 0x1 = 0x108 
user@DESKTOP-THMS2PJ:~$ </code>
<li>0x100 + 0x1 = 0x108
<li>Okay that seems pretty bad, fair enough.
</section>

<section>
<h2>C... Bad?</h2>
<ul>
<li>At least it's consistent.
<code>printf("%p + %p = %p \n", (void *)p, (void *)x, (void *)((char *)p + x)) ;
printf("%p + %p = %p \n", (void *)p, (void *)x, (void *)((int  *)p + x)) ; 
printf("%p + %p = %p \n", (void *)p, (void *)x, (void *)((long *)p + x)) ;</code>
<li>All 0x108 I'm sure.
<code>user@DESKTOP-THMS2PJ:~$ ./a.out
0x100 + 0x1 = 0x101 
0x100 + 0x1 = 0x104 
0x100 + 0x1 = 0x108 
user@DESKTOP-THMS2PJ:~$ </code>
<li>WAIT A MINUTE
</section>

<section>
<h2>C... Bad?</h2>
<ul>
<li>"This is called operator overloading. It's not allowed in C."
<li>Addition and subtraction are overloaded in C.
<ul><li>My advice: Never use either.</ul>
<li>In C, addition is specifically defined in the case where pointer has a numerical value added to it.
<ul><li>int *  + int
<li>int *  + long
<li>char * + int
<li>long * + char</ul>
<li>Subtraction is defined on two numeric types or two pointer types.
<li>Pointer + pointer is not allowed.
<code>hi.c: In function ‘main’:
hi.c:11:76: error: invalid operands to binary + (have ‘char *’ and ‘char *’)
   11 |         printf("%p\n", (char *)p + (char *)x ) ;</code>
<li>C cleverly calls this "pointer arithmetic" so we can pretend operator overloading isn't allowed in C.
<li>C good! Python bad! We did it team! Firm handshakes all around.
</section>

<section>
<h2>Wait what about []</h2>
<ul>
<li>I have terrible news about arrays.
<li>Pointer arithmetic all the way down my friends.
<code>int arr[4] = { 0x10, 0x100, 0x1000, 0x10000 } ;
printf("  arr+1 : %p\n",   arr+1)  ;
printf("*(arr+1): %p\n", *(arr+1)) ;
printf("(*arr+1): %p\n", (*arr+1)) ;
printf("  arr[1]: %p\n",   arr[1]) ;</code>
<li>"Wow that is so easy to read and such a useable language." - me, to myself
<code>  arr+1 : 0x7fff5956cce4
*(arr+1): 0x100
(*arr+1): 0x11
  arr[1]: 0x100</code>
<li>Oh perfect - arr[n] is logically equivalent to *(arr+n) ;
</section>

<section>
<h2>arr[n] = *(arr+n)</h2>
<ul>
<li>Test it.
<code>int main()
{
    int arr[4] = { 0x10, 0x100, 0x1000, 0x10000 }, i ;
    for ( i = 0 ; i < 4 ; i++ )
    {
        printf("*(arr+%d): %5x,   arr[%d]: %5x\n", i, *(arr+i), i, arr[i]) ;
    }
    return 0;
}</code>
<li>"Come sail away, come sail away, come sail away with C" - me
<code>user@DESKTOP-THMS2PJ:~$ gcc hi.c ; ./a.out
*(arr+0):    10,   arr[0]:    10
*(arr+1):   100,   arr[1]:   100
*(arr+2):  1000,   arr[2]:  1000
*(arr+3): 10000,   arr[3]: 10000
user@DESKTOP-THMS2PJ:~$ </code>
<li>arr[n] is logically equivalent to *(arr+n).
</section>

<section>
<h2>arr[n] = *(arr+n)</h2>
<ul>
<li>Literally never do this ever for any reason.
<code>int main()
{
    int arr[4] = { 0x10, 0x100, 0x1000, 0x10000 }, i ;
    for ( i = 0 ; i < 4 ; i++ )
    {
        printf("%d[arr]: %5x\n", i, i[arr]) ;
    }
    printf("1[(long *)arr: %5lx\n", 1[(long *)arr]); // NO!
    return 0;
}</code>
<li>I am going to become the joker.
<code>user@DESKTOP-THMS2PJ:~$ gcc hi.c ; ./a.out
0[arr]:    10
1[arr]:   100
2[arr]:  1000
3[arr]: 10000
1[(long *)arr]:  1000
user@DESKTOP-THMS2PJ:~$ </code>
</section>

<section>
<h2>Today</h2>
<dl>
<dt>✓ Malloc part 2</dt>
<dd>✓ free()
</dd>
<dd>
</dd>
<dt>Memory-adjacent tech</dt>
<dd>✓ casting</dd>
<dd>✓ pointer arithmetic</dd>
<dd>unary &</dd>
</dl>
</section>

<section>
<h2>Unary & </h2>
<ul>
<li>& is both a unary and binary operator in C, like - (minus)
<code>int main()
{
	int x ;
	x = 1 - 2 ;
	x = - 2   ;
	int y ;
	x = 0x11  ;
	y = 0x10  ;
	x = x & y ; // BITWISE and, so 0x10 
	x = & y   ; // is this allowed?
	return 0;
}</code>
<li>What does unary & do?
<code>hi.c: In function ‘main’:
hi.c:15:11: warning: assignment to ‘int’ from ‘int *’ makes integer from pointer without a cast [-Wint-conversion]
   15 |         x = & y   ;
      |           ^ </code>
</section>

<section>
<h2>Unary & </h2>
<ul>
<code>hi.c: In function ‘main’:
hi.c:15:11: warning: assignment to ‘int’ from ‘int *’ makes integer from pointer without a cast [-Wint-conversion]
   15 |         x = & y   ;
      |           ^ </code>
<li>Pointers! Our* favorite**!
<li>We know how to examine these.
<code>int main()
{
	int x = 0xF0, y = 0x0F, *p ; // just unique vals
	p = &y ;
	printf("*p = %x, p = %p\n", *p, p) ; 
	return 0;
}</code>
<li>This gives us:
<code>user@DESKTOP-THMS2PJ:~$ gcc hi.c ; ./a.out
*p = f, p = 0x7fff37619e98
user@DESKTOP-THMS2PJ:~$</code>
<li>Ah ha, & is inverse *.
</section>

<section>
<h2>Unary & is inverse *</h2>
<ul>
<code>int main()
{
	int x = 0xF0, y = 0x0F, *p ; // just unique vals
	p = &y ;
	printf("*p = %x,  p = %p\n", *p,  p) ; 
	printf(" y = %x, &y = %p\n",  y, &y) ; 
	return 0;
}</code>
<li>p = &y -> *p = y
<code>user@DESKTOP-THMS2PJ:~$ gcc hi.c ; ./a.out
*p = f,  p = 0x7ffc85ee5f68
 y = f, &y = 0x7ffc85ee5f68
user@DESKTOP-THMS2PJ:~$ </code>
<li>I bet it works in reverse.
</section>

<section>
<h2>* is not inverse Unary &</h2>
<ul>
<code>int main()
{
	int x = 0xF0, y = 0x0F, *p ; // just unique vals
	*p = y ;
	printf("*p = %x,  p = %p\n", *p,  p) ;
	printf(" y = %x, &y = %p\n",  y, &y) ; 
	return 0;
}</code>
<li>*p = y -/> p = &y
<code>user@DESKTOP-THMS2PJ:~$ gcc hi.c ; ./a.out
Segmentation fault
user@DESKTOP-THMS2PJ:~$ </code>
<li>p is an unitialized pointer, and dereferencing (with *) an uninitialized pointer causes a segfault at high probability.
</section>

<section>
<h2>* is not inverse Unary &</h2>
<ul>
<li>Outmanuever segmentation faults with judicious use of malloc() and free().
<code>int main()
{
	int x = 0xF0, y = 0x0F, *p = (int *)malloc(sizeof(int)); // just unique vals
	*p = y ;
	printf("*p = %x,  p = %p\n", *p,  p) ;
	printf(" y = %x, &y = %p\n",  y, &y) ; 
	free(p) ;
	return 0;
}</code>
<li>But this just means the value of y is stored at p, not that p points to y.
<code>user@DESKTOP-THMS2PJ:~$ gcc hi.c ; ./a.out
*p = f,  p = 0x556ae59ec2a0
 y = f, &y = 0x7ffc47f075c8
user@DESKTOP-THMS2PJ:~$ </code>
<li>*p = y creates a copy of the value stored in y.
</section>

<section>
<h2>Today</h2>
<dl>
<dt>Malloc part 2</dt>
<dd>✓ free()
<dd style="background-color:red">Checking malloc return value
</dd>
<dd>
</dd>
<dt>✓ Memory-adjacent tech</dt>
<dd>✓ casting</dd>
<dd>✓ pointer arithmetic</dd>
<dd>✓ unary &</dd>
</dl>
</section>

<section>
<h2>Malloc fails</h2>
<ul>
<li>There is no guarantee that your malloc actually gets the memory it asks for.
<ul><li>In fact, its impossible to make a computer that guarantees this.
<li>Rather, it is very likely to return correctly.
<li>But you must check.</ul>
<code>int main()
{
	int x = 0xF0, y = 0x0F, *p = (int *)malloc(sizeof(int)); // just unique vals
	if (p == 0) { fprintf(stderr, "Malloc failed.\n") ; exit(-1) ; }
	*p = y ;
	printf("*p = %x,  p = %p\n", *p,  p) ;
	printf(" y = %x, &y = %p\n",  y, &y) ; 
	free(p) ;
	return 0;
}</code>
<li>This is what exit is for.
<li>fprintf is like printf but doesn't just go to "stdout".
<ul><li>Stderr is a lot like stdout but also different (we'll get there).
<li>It shows up in terminal.
</section>

<section>
<h2>Malloc fails</h2>
<ul>
<li>We can trigger an P=1 failure with by using -1 to get the maximum possible size_t value.
<code>int main()
{
	void *p = malloc(-1);
	if (p == 0) { fprintf(stderr, "Malloc failed.\n") ; exit(-1) ; }
	return 0;
}</code>
<li>We draw a compile warning (you can fail mallocs without this, but fail at 100% rate with these):
<code>user@DESKTOP-THMS2PJ:~$ gcc hi.c
hi.c: In function ‘main’:
hi.c:6:19: warning: argument 1 value ‘18446744073709551615’ exceeds maximum object size 9223372036854775807 [-Walloc-size-larger-than=]
    6 |         void *p = malloc(-1);
      |                   ^~~~~~~~~~
In file included from hi.c:2:
/usr/include/stdlib.h:540:14: note: in a call to allocation function ‘malloc’ declared here
  540 | extern void *malloc (size_t __size) __THROW __attribute_malloc__
      |              ^~~~~~
user@DESKTOP-THMS2PJ:~$ </code>

</section>

<section>
<h2>Malloc fails</h2>
<ul>
<li>We can trigger an P=1 failure with by using -1 to get the maximum possible size_t value.
<code>int main()
{
	void *p = malloc(-1);
	if (p == 0) { fprintf(stderr, "Malloc failed.\n") ; exit(-1) ; }
	return 0;
}</code>
<li>If we run the code:
<code>user@DESKTOP-THMS2PJ:~$ ./a.out
Malloc failed.
user@DESKTOP-THMS2PJ:~$ </code>
<li>If malloc fails and you attempt to use the pointer, you will segfault.
<li>If that happens and you ask me for help I'll send you this slide!
<li>C! It's fun!
</section>

<section>
<h2>Today</h2>
<dl>
<dt>✓ Malloc part 2</dt>
<dd>✓ free()
<dd>✓ Checking malloc return value
</dd>
<dd>
</dd>
<dt>✓ Memory-adjacent tech</dt>
<dd>✓ casting</dd>
<dd>✓ pointer arithmetic</dd>
<dd>✓ unary &</dd>
</dl>
</section>

    </div>
  </div>

  <script src="https://cd-public.github.io/slides/html_srcs/reveal.js/dist/reveal.js"></script>

  // reveal.js plugins
  <script src="https://cd-public.github.io/slides/html_srcs/reveal.js/plugin/notes/notes.js"></script>
  <script src="https://cd-public.github.io/slides/html_srcs/reveal.js/plugin/search/search.js"></script>
  <script src="https://cd-public.github.io/slides/html_srcs/reveal.js/plugin/zoom/zoom.js"></script>
  <script src="https://cd-public.github.io/slides/html_srcs/reveal.js/plugin/chart/Chart.min.js"></script>
  <script src="https://cd-public.github.io/slides/html_srcs/reveal.js/plugin/chart/plugin.js"></script>
  <script src="https://cd-public.github.io/slides/html_srcs/reveal.js/plugin/chalkboard/plugin.js"></script>
  <script src="https://cd-public.github.io/slides/html_srcs/reveal.js/plugin/math/math.js"></script>
  <script src="https://cd-public.github.io/slides/html_srcs/reveal.js/plugin/highlight/highlight.js"></script>

  <script>
      Reveal.initialize({
        progress: true,
        slideNumber: true,
        hash: true,
        keyboard: true,
        overview: true,
        center: false,
        touch: true,
        loop: false,
        rtl: false,
        navigationMode: 'default',
        shuffle: false,
        fragmentInURL: true,
        embedded: false,
        help: true,
        showNotes: false,
        preloadIframes: null,
        autoSlide: 0,
        autoSlideStoppable: true,
        autoSlideMethod: null,
        defaultTiming: null,
        hideInactiveCursor: true,
        hideCursorTime: 5000,
        previewLinks: false,
        transition: 'slide', // none/fade/slide/convex/concave/zoom
        transitionSpeed: 'default', // default/fast/slow
        backgroundTransition: 'fade', // none/fade/slide/convex/concave/zoom
        viewDistance: 3,
        mobileViewDistance: 2,
        width: 1920,
        height: 1200,
        display: 'block',
		math: {
		  CommonHTML: {scale: 80},
		},
	reveald3: {
			runLastState: true, // true/false, default: true
			onSlideChangedDelay: 200,
			mapPath: false, // true / false / "spefific/path/as/string", default: false
			tryFallbackURL: true, // true/false, default false
			disableCheckFile: false, //default false
		 },

        // reveal.js plugins
        plugins: [
		  RevealMath,
          RevealHighlight,
          RevealNotes,
          RevealSearch,
          RevealZoom,
		  RevealChart,
		  RevealChalkboard,
        ],
		chalkboard: {
		boardmarkerWidth: 4,
        chalkWidth: 7,
		boardmarkers : [
                { color: 'rgba(248,248,242,1)', cursor: 'url(' + path + 'img/boardmarker-black.png), auto'},
                { color: 'rgba(102,217,239,1)', cursor: 'url(' + path + 'img/boardmarker-blue.png), auto'},
                { color: 'rgba(249,38,114,1)', cursor: 'url(' + path + 'img/boardmarker-red.png), auto'},
                { color: 'rgba(166,226,46,1)', cursor: 'url(' + path + 'img/boardmarker-green.png), auto'},
                { color: 'rgba(253,151,31,1)', cursor: 'url(' + path + 'img/boardmarker-orange.png), auto'},
                { color: 'rgba(174,129,255,1)', cursor: 'url(' + path + 'img/boardmarker-purple.png), auto'},
                { color: 'rgba(255,231,146,1)', cursor: 'url(' + path + 'img/boardmarker-yellow.png), auto'}
        ],
        chalks: [
                { color: 'rgba(248,248,242,0.5)', cursor: 'url(' + path + 'img/chalk-white.png), auto'},
                { color: 'rgba(102,217,239,0.5)', cursor: 'url(' + path + 'img/chalk-blue.png), auto'},
                { color: 'rgba(249,38,114,0.5)', cursor: 'url(' + path + 'img/chalk-red.png), auto'},
                { color: 'rgba(166,226,46,0.5)', cursor: 'url(' + path + 'img/chalk-green.png), auto'},
                { color: 'rgba(253,151,31,0.5)', cursor: 'url(' + path + 'img/chalk-orange.png), auto'},
                { color: 'rgba(174,129,255,0.5)', cursor: 'url(' + path + 'img/chalk-purple.png), auto'},
                { color: 'rgba(255,231,146,0.5)', cursor: 'url(' + path + 'img/chalk-yellow.png), auto'}
        ]
		},
		dependencies: [
			{ src: "https://cd-public.github.io/slides/html_srcs/reveal.js/plugin/title-footer/title-footer.js", async: true, callback: function() { title_footer.initialize({css:"https://cd-public.github.io/slides/html_srcs/reveal.js/plugin/title-footer/title-footer.css"}); } },
			{ src: "https://cd-public.github.io/slides/html_srcs/reveal.js/plugin/d3/reveald3.js" },
		],
      });
    </script>
    </body>
</html>
