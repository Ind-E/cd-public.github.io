<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>gdb</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <style>
    code{white-space: pre-wrap;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="https://cd-public.github.io/slides/html_srcs/reveal.js/dist/theme/sky.css" id="theme">
  <link rel="stylesheet" href="https://cd-public.github.io/slides/html_srcs/reveal.js/plugin/highlight/monokai.css">
  <link rel="stylesheet" href="C:\Users\cd-desk\Documents\dev\local\js/reset.css">
  <link rel="stylesheet" href="https://cd-public.github.io/slides/html_srcs/reveal.js/dist/reveal.css">
  <script src="https://cd-public.github.io/slides/html_srcs/reveal.js/dist/reveal.js"></script>
  <script src="https://cd-public.github.io/slides/html_srcs/reveal.js/plugin/highlight/highlight.js"></script>
</head>
<body>
  <div class="reveal">
    <div class="slides">

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GDB Tutorial</title>
</head>
<body>

<section>
<br><br><br>
  <h1 style="font-family: monospace;text-transform: lowercase;">gdb</h1>
  <h2>CS 271</h2>
  <h2>Prof. Calvin</h2>
  <h2>async</h2>
  <h2>slice</h2>
</section>


<section>
<h2>Announcements</h2>
<ul>
<li>You have a robust code base and just be debugging.
<li>Let's learn a debugger.
<li>I stole this from someone who spent 13 years working on a Ph.D. and is now at AWS
<li> (Samuel Huang)
</section>
<section>
<h2>Today</h2>
<dl>
<dt>gdb</dt>
<dd>intro/invocation
<dd>breakpoints
<dd>debugging
<dd>conditions
<dd>pointers
</section>

<section>
    <h2>What is gdb?</h2>
    <ul>
        <li>“GNU Debugger”</li>
        <li>A debugger for several languages, including C and C++</li>
        <li>It allows you to inspect what the program is doing at a certain point during execution.</li>
        <li>Errors like segmentation faults may be easier to find with the help of gdb.</li>
        <li><a href="http://sourceware.org/gdb/current/onlinedocs/gdbtoc.html">Online manual</a></li>
    </ul>
</section>

<section>
    <h2>Additional step when compiling program</h2>
    <ul>
        <li>Normally, you would compile a program like:</li>
        <code>gcc [flags] &lt;source files&gt; -o &lt;output file&gt;</code></li>
        <li>For example: <code>gcc -Wall -Werror -ansi -pedantic-errors prog1.c -o prog1.x</code></li>
        <li>Now you add a <code>-g</code> option to enable built-in debugging support (which gdb needs):</li>
        <li>For example: <code>gcc -Wall -Werror -ansi -pedantic-errors -g prog1.c -o prog1.x</code></li>
    </ul>
	<p>What do all those flags do?
</section>

<section>
    <h2>Starting up gdb</h2>
    <ul>
        <li>Just try <code>gdb</code> or <code>gdb prog1.x</code> You’ll get a prompt that looks like this:</li>
        <code>(gdb)</code>
        <li>If you didn’t specify a program to debug, you’ll have to load it in now:</li>
        <code>(gdb) file prog1.x</code>
        <li>Here, <code>prog1.x</code> is the program you want to load, and <code>file</code> is the command to load it.</li>
    </ul>
</section>

<section>
    <h2>Before we go any further</h2>
    <ul>
        <li>gdb has an interactive shell, like Python. It can recall history with the arrow keys, auto-complete words (most of the time) with the TAB key, and has other nice features.</li>
        <li><strong>Tip:</strong> If you’re ever confused about a command or just want more information, use the <code>help</code> command, with or without an argument:</li>
        <code>(gdb) help [command]</code>
        <li>You should get a nice description and maybe some more useful tidbits.</li>
    </ul>
</section>

<section>
    <h2>Running the program</h2>
    <ul>
        <li>To run the program, just use:</li>
        <code>(gdb) run</code>
        <li>This runs the program.</li>
        <li>If it has no serious problems (i.e. the normal program didn’t get a segmentation fault, etc.), the program should run fine here too.</li>
        <li>If the program did have issues, then you (should) get some useful information like the line number where it crashed, and parameters to the function that caused the error:</li>
         <code>Program received signal SIGSEGV, Segmentation fault. 0x0000000000400524 in sum array region (arr=0x7fffc902a270, r1=2, c1=5, r2=4, c2=6) at sum-array-region2.c:12</code>
    </ul>
</section>

<section>
    <h2>So what if I have bugs?</h2>
    <ul>
        <li>Okay, so you’ve run it successfully. But you don’t need gdb for that. What if the program isn’t working?</li>
        <li><strong>Basic idea:</strong> Chances are if this is the case, you don’t want to run the program without any stopping, breaking, etc. Otherwise, you’ll just rush past the error and never find the root of the issue. So, you’ll want to step through your code a bit at a time, until you arrive upon the error.</li>
        <li>This brings us to the next set of commands...</li>
    </ul>
</section>

<section>
    <h2>Setting breakpoints</h2>
    <ul>
        <li>Breakpoints can be used to stop the program run in the middle, at a designated point. The simplest way is the command <code>break</code>.</li>
        <li>This sets a breakpoint at a specified file-line pair:</li>
        <li><code>(gdb) break file1.c:6</code></li>
        <li>This sets a breakpoint at line 6, of file1.c. Now, if the program ever reaches that location when running, the program will pause and prompt you for another command.</li>
        <li><strong>Tip:</strong> You can set as many breakpoints as you want, and the program should stop execution if it reaches any of them.</li>
    </ul>
</section>

<section>
    <h2>More fun with breakpoints</h2>
    <ul>
        <li>You can also tell gdb to break at a particular function. Suppose you have a function <code>my func:</code></li>
        <li><code>int my func(int a, char *b);</code></li>
        <li>You can break anytime this function is called:</li>
        <li><code>(gdb) break my func</code></li>
    </ul>
</section>

<section>
    <h2>Now what?</h2>
    <ul>
        <li>Once you’ve set a breakpoint, you can try using the <code>run</code> command again. This time, it should stop where you tell it to (unless a fatal error occurs before reaching that point).</li>
        <li>You can proceed onto the next breakpoint by typing <code>continue</code> (Typing <code>run</code> again would restart the program from the beginning, which isn’t very useful.)</li>
        <li>You can single-step (execute just the next line of code) by typing <code>step</code>. This gives you really fine-grained control over how the program proceeds. You can do this a lot...</li>
    </ul>
</section>

<section>
    <h2>Now what? (even more!)</h2>
    <ul>
        <li>Similar to <code>step</code>, the <code>next</code> command single-steps as well, except this one doesn’t execute each line of a sub-routine, it just treats it as one instruction.</li>
        <li><strong>Tip:</strong> Typing <code>step</code> or <code>next</code> a lot of times can be tedious. If you just press ENTER, gdb will repeat the same command you just gave it. You can do this a bunch of times.</li>
    </ul>
</section>

<section>
    <h2>Querying other aspects of the program</h2>
    <ul>
        <li>So far you’ve learned how to interrupt program flow at fixed, specified points, and how to continue stepping line-by-line. However, sooner or later you’re going to want to see things like the values of variables, etc. This might be useful in debugging.</li>
        <li>The <code>print</code> command prints the value of the variable specified, and <code>print/x</code> prints the value in hexadecimal:</li>
        <li><code>(gdb) print my var</code></li>
        <li><code>(gdb) print/x my var</code></li>
    </ul>
</section>

<section>
    <h2>Setting watchpoints</h2>
    <ul>
        <li>Whereas breakpoints interrupt the program at a particular line or function, watchpoints act on variables. They pause the program whenever a watched variable’s value is modified.</li>
        <li>For example, the following watch command:</li>
        <li><code>(gdb) watch my var</code></li>
        <li>Now, whenever <code>my var</code>’s value is modified, the program will interrupt and print out the old and new values.</li>
        <li><strong>Tip:</strong> You may wonder how gdb determines which variable named <code>my var</code> to watch if there is more than one declared in your program. The answer (perhaps unfortunately) is that it relies upon the variable’s scope, relative to where you are in the program at the time of the watch. This just means that you have to remember the tricky nuances of scope and extent.</li>
    </ul>
</section>

<section>
    <h2>Example programs</h2>
    <ul>
        <li>Some example files are found in <code>~/212public/gdb-examples/broken.c</code> on the linux grace machines.</li>
        <li>Contains several functions that each should cause a segmentation fault. (Try commenting out calls to all but one in main())</li>
        <li>The errors may be easy, but try using gdb to inspect the code.</li>
    </ul>
</section>

<section>
    <h2>Other useful commands</h2>
    <ul>
        <li><code>backtrace</code> - produces a stack trace of the function calls that lead to a seg fault (should remind you of Java exceptions)</li>
        <li><code>where</code> - same as <code>backtrace</code>; you can think of this version as working even when you’re still in the middle of the program</li>
        <li><code>finish</code> - runs until the current function is finished</li>
        <li><code>delete</code> - deletes a specified breakpoint</li>
        <li><code>info breakpoints</code> - shows information about all declared breakpoints</li>
        <li>Look at sections 5 and 9 of the manual mentioned at the beginning of this tutorial to find other useful commands, or just try <code>help</code>.</li>
    </ul>
</section>

<section>
    <h2>gdb with Emacs</h2>
    <ul>
        <li>Emacs also has built-in support for gdb. To learn about it, go <a href="http://tedlab.mit.edu/~dr/gdbintro.html">here</a>.</li>
    </ul>
</section>

<section>
    <h2>More about breakpoints</h2>
    <ul>
        <li>Breakpoints by themselves may seem too tedious. You have to keep stepping, and stepping, and stepping...</li>
        <li><strong>Basic idea:</strong> Once we develop an idea for what the error could be (like dereferencing a NULL pointer, or going past the bounds of an array), we probably only care if such an event happens; we don’t want to break at each iteration regardless.</li>
        <li>So ideally, we’d like to condition on a particular requirement (or set of requirements). Using conditional breakpoints allow us to accomplish this goal...</li>
    </ul>
</section>

<section>
    <h2>Conditional breakpoints</h2>
    <ul>
        <li>Just like regular breakpoints, except that you get to specify some criterion that must be met for the breakpoint to trigger. We use the same <code>break</code> command as before:</li>
        <li><code>(gdb) break file1.c:6 if i >= ARRAYSIZE</code></li>
        <li>This command sets a breakpoint at line 6 of file file1.c, which triggers only if the variable <code>i</code> is greater than or equal to the size of the array (which probably is bad if line 6 does something like <code>arr[i]</code>). Conditional breakpoints can most likely avoid all the unnecessary stepping, etc.</li>
    </ul>
</section>

<section>
    <h2>Fun with pointers</h2>
    <ul>
        <li>Who doesn’t have fun with pointers? First, let’s assume we have the following structure defined:</li>
        <li><code>struct entry { int key; char *name; float price; long serial_number; };</code></li>
        <li>Maybe this struct is used in some sort of hash table as part of a catalog for products, or something related.</li>
    </ul>
</section>

<section>
    <h2>Using pointers with gdb I</h2>
    <ul>
        <li>Now, let’s assume we’re in gdb, and are at some point in the execution after a line that looks like:</li>
        <li><code>struct entry * e1 = &lt;something&gt;;</code></li>
        <li>We can do a lot of stuff with pointer operations, just like we could in C.</li>
        <li>See the value (memory address) of the pointer:</li>
        <li><code>(gdb) print e1</code></li>
        <li>See a particular field of the struct the pointer is referencing:</li>
        <li><code>(gdb) print e1-&gt;key</code></li>
        <li><code>(gdb) print e1-&gt;name</code></li>
        <li><code>(gdb) print e1-&gt;price</code></li>
        <li><code>(gdb) print e1-&gt;serial number</code></li>
    </ul>
</section>

<section>
    <h2>Using pointers with gdb II</h2>
    <ul>
        <li>You can also use the dereference (<code>*</code>) and dot (<code>.</code>) operators in place of the arrow operator (<code>-&gt;</code>):</li>
        <li><code>(gdb) print (*e1).key</code></li>
        <li><code>(gdb) print (*e1).name</code></li>
        <li><code>(gdb) print (*e1).price</code></li>
        <li><code>(gdb) print (*e1).serial number</code></li>
        <li>See the entire contents of the struct the pointer references (you can’t do this as easily in C!):</li>
        <li><code>(gdb) print *e1</code></li>
        <li>You can also follow pointers iteratively, like in a linked list:</li>
        <li><code>(gdb) print list prt-&gt;next-&gt;next-&gt;next-&gt;data</code></li>
    </ul>
</section>

</body>
</html>


<section>
<h2>Today</h2>
<dl>
<dt>✓ Makefile</dt>
<dd>✓ rules
<dd>✓ .o files
<dd>✓ compile flags
</section>



 </div>
  </div>
  <script>
      Reveal.initialize({
        progress: true,
        slideNumber: true,
        center: false,
        fragmentInURL: true,
        width: 1920,
        height: 1200,
        display: 'block',
        // reveal.js plugins
        plugins: [
          RevealHighlight,
        ],
      });
    </script>
    </body>
</html>
