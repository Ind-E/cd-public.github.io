[
  {
    "objectID": "sha256.html",
    "href": "sha256.html",
    "title": "Announcements",
    "section": "",
    "text": "title: SHA256 author: Prof. Calvin subtitle: “Week 0x2” institute: Crypto format: revealjs: code-fold: false theme: dark mainfont: monospace slide-number: true show-slide-number: all width: 1050 height: 700\nexecute: echo: true cache: true freeze: true # never re-render during project render"
  },
  {
    "objectID": "sha256.html#sha-256-overview",
    "href": "sha256.html#sha-256-overview",
    "title": "Podman",
    "section": "SHA-256 Overview",
    "text": "SHA-256 Overview\n\nSHA: Secure Hash Algorithm, 256-bit output length\nAccepts bit strings of length up to \\(2^{64} - 1\\)"
  },
  {
    "objectID": "sha256.html#two-stages",
    "href": "sha256.html#two-stages",
    "title": "Podman",
    "section": "Two Stages",
    "text": "Two Stages\n\nOutput calculation has two stages:\n\nPreprocessing\nHash Computation"
  },
  {
    "objectID": "sha256.html#preprocessing",
    "href": "sha256.html#preprocessing",
    "title": "Podman",
    "section": "Preprocessing",
    "text": "Preprocessing\n\nA 256-bit state variable \\(H^{(0)}\\) is initialized:\n\n\\[\\begin{align*}\n\\begin{split}\n   H_0^{(0)} = \\texttt{0x6A09E667}, \\quad H_1^{(0)} = \\texttt{0xBB67AE85},\\\\\n   H_2^{(0)} = \\texttt{0x3C6EF372}, \\quad H_3^{(0)} = \\texttt{0xA54FF53A},\\\\\n   H_4^{(0)} = \\texttt{0x510E527F}, \\quad H_5^{(0)} = \\texttt{0x9B05688C},\\\\\n   H_6^{(0)} = \\texttt{0x1F83D9AB}, \\quad H_7^{(0)} = \\texttt{0x5BE0CD19}.\n\\end{split}\n   \\end{align*}\\]\n\nThe input \\(M\\) is padded to a length that is a multiple of 512."
  },
  {
    "objectID": "sha256.html#input-padding",
    "href": "sha256.html#input-padding",
    "title": "Podman",
    "section": "Input Padding",
    "text": "Input Padding\n\nLet ( M ) be ( l )-bits long.\nFind the smallest non-negative ( k ) such that: [ k + l + 65 = 0 ]\nAppend ( k + 1 ) bits: a single 1 followed by ( k ) zeros.\nAppend a 64-bit representation of ( l ).\n\nExample:\n( M = 101010 ) with ( l = 6 ) - ( k = 441 ) - 64-bit representation of ( l ): ( 00000110 ) - 512-bit padded message:\n101010︸M 1︸Single 1 00000 ··· 00000︸441 zeros 00···00110︸l"
  },
  {
    "objectID": "sha256.html#hash-computation",
    "href": "sha256.html#hash-computation",
    "title": "SHA256",
    "section": "Hash Computation",
    "text": "Hash Computation\n\nPadded input is split into \\(N\\) 512-bit blocks: \\(M^{(1)}, M^{(2)}, \\ldots, M^{(N)}\\).\nGiven \\(H(i-1)\\), calculate \\(H(i)\\) using: \\[\nH(i) = f(M^{(i)}, H(i-1)), \\quad 1 \\leq i \\leq N.\n\\]\nThe compression function \\(f\\) processes each block."
  },
  {
    "objectID": "sha256.html#compression-function-building-blocks",
    "href": "sha256.html#compression-function-building-blocks",
    "title": "SHA256",
    "section": "Compression Function Building Blocks",
    "text": "Compression Function Building Blocks\n\nBitwise operations:\n\\(U \\land V\\), \\(U \\lor V\\), \\(U \\oplus V\\): AND, OR, XOR\n\\(\\lnot U\\): bitwise complement\n\\(SHR_n(U)\\): shift right by \\(n\\)\n\\(ROTR_n(U)\\): rotate right by \\(n\\)\nSpecial functions: \\[\n\\text{Ch}(U, V, W) = (U \\land V) \\oplus (\\lnot U \\land W)\n\\] \\[\n\\text{Maj}(U, V, W) = (U \\land V) \\oplus (U \\land W) \\oplus (V \\land W)\n\\] \\[\n\\Sigma_0(U) = ROTR_2(U) \\oplus ROTR_{13}(U) \\oplus ROTR_{22}(U)\n\\] \\[\n\\Sigma_1(U) = ROTR_6(U) \\oplus ROTR_{11}(U) \\oplus ROTR_{25}(U)\n\\]"
  },
  {
    "objectID": "sha256.html#compression-function-calculation",
    "href": "sha256.html#compression-function-calculation",
    "title": "SHA256",
    "section": "Compression Function Calculation",
    "text": "Compression Function Calculation\n\nInternal State Initialization: \\[\nW_j =\n\\begin{cases}\nM^{(i)}_j & 0 \\leq j \\leq 15 \\\\\n\\sigma_1(W_{j-2}) + W_{j-7} + \\sigma_0(W_{j-15}) + W_{j-16} & 16 \\leq j \\leq 63\n\\end{cases}\n\\]\nInitialize eight 32-bit words: \\[\n(A, B, C, D, E, F, G, H) = (H(i-1)_0, \\ldots, H(i-1)_7).\n\\]\nIterate \\(j = 0\\) to \\(63\\): \\[\nT_1 = H + \\Sigma_1(E) + \\text{Ch}(E, F, G) + K_j + W_j\n\\] \\[\nT_2 = \\Sigma_0(A) + \\text{Maj}(A, B, C)\n\\] \\[\n(A, B, C, D, E, F, G, H) = (T_1 + T_2, A, B, C, D + T_1, E, F, G)\n\\]\nUpdate \\(H(i)\\): \\[\nH(i)_j = A + H(i-1)_j, \\quad j = 0, \\ldots, 7\n\\]"
  },
  {
    "objectID": "sha256.html#the-merkle-damgård-transform",
    "href": "sha256.html#the-merkle-damgård-transform",
    "title": "SHA256",
    "section": "The Merkle-Damgård Transform",
    "text": "The Merkle-Damgård Transform\n\nConstruction: Example of MD transform.\nPurpose: Extend domain to construct collision-resistant hash functions."
  },
  {
    "objectID": "sha256.html#references",
    "href": "sha256.html#references",
    "title": "SHA256",
    "section": "References",
    "text": "References\n\nChapter 3 of An Introduction to Bitcoin, S. Vijayakumaran\nwww.ee.iitb.ac.in/~sarva/bitcoin.html"
  },
  {
    "objectID": "enigma.html",
    "href": "enigma.html",
    "title": "Enigma",
    "section": "",
    "text": "Enigma Show\n\n\nGoal: Learn C I/O and strings\n\nMy responsibility\n\nI will provide a reference solution in Python (solved)\nI will provide an autograder Containerfile (tester)\n\nYour responsibility\n\nYou will create a solution in C as an “enigma.c” file\nYou will create a Gist with an “enigma.c”\nYou will email me, from your credentialed school email, the url of your Gist, it will look something like:\n\nhttps://gist.github.com/cd-public/a840e95e71ac7309a53ab0bb1282ba40\nWhat follows is reference material to prepare you to implement “enigma.c”\n\nEnigma, Solved, Visual, and Rotors form a description of the requirements\nTester documents the autograder\nOther headings cover the technical details that support the implementation.\n\n\n\n\nTopic Areas\n\n\n\nReview:\nNewish:\n\n\n\n\n- podman\n- curl\n\n\n- vim\n- stdio\n\n\n- gcc\n- ciphers\n\n\n- git\n\n\n\n\n\n\nMotivation\n\nEnigma was a historically significant technology\n\nIt was a Nazi encryption device, using ciphers\nIt was broken by Turing, gay icon and one of the first and greatest computer scientists\n\nAt Willamette, Enigma is an (in)famous CS 151 Intro to Programming assignment\n\nBasically it is the first assignment that requires nested for loops\n\nIn this course, Enigma will demonstrate the obscurity/clarity divide\n\nIn Python, letters and numbers are different things\nIn C, there are no letters or really numbers, just bits and bytes\nThis makes Enigma in C easier, despite being a “harder” language.\n\n\n\n\nReference Materials\n\nYou can review the Python assignment if you wish:\n\nWrite-ups:\n\nProf. Roberts\nProf. Rembold\nProf. Calvin\n\nSlides\n\nProf. Rembold\nProf. Calvin\n\nAssignment Repository\n\nI also provide\n\n“Solved”: A Python implementation of the machine\n“Visual”: A text visualizer of the Engima machine’s ciphers\n“Rotors”: A text visualizer of the full Enigma machine\n\n\n\n\n\n\nSolved Show\n\n\nHere is a reference solution, with a few tests, in Python.\n\nGist\n\nI regard this code as considerably easier to read, test, and understand than most plaintext descriptions.\nI will also do a visual representation.\nThe ciphers are sometimes called “rotors” because historically they were implemented as a rotating… cipher.\n\n#!/usr/bin/env python3\n\n# constants                       # constant\nrs = [                            # rotors\n    \"BDFHJLCPRTXVZNYEIWGAKMUSQO\", # fast\n    \"AJDKSIRUXBLHWTMCQGZNPYFVOE\", # medium\n    \"EKMFLGDQVZNTOWYHXUSPAIBRCJ\", # slow\n    \"IXUHFEZDAOMTKQJWNSRLCYPBVG\"  # reflect\n]\nA  = ord('A')                     # value of 'A'\nNC = len(rs[0])                   # number of characters\n\n# apply a cipher/rotor `r` to a letter `c`\nrapply = lambda c, r : r[ord(c) - A]\n\n# invert a cipher/rotor `r`\n    # create a list of letters with their index\n        # [(r[i],i) for i in range(NC)]\n    # sort the list\n        # for p in sorted\n    # convert indexes to back to letters in the alphabet\n        # chr(p[1]+A)\ninvert = lambda r : [chr(p[1]+A) for p in sorted([(r[i],i) for i in range(NC)])]\n\n# extend the rotor set to include inverted ciphers\n    # In reversed order, as well\n    # fas med slo ref slo med fas\nrs += [invert(r) for r in rs[2::-1]]\n\n# encrypt letter `c` with rotors in default* positions\nrotors = lambda c : [c := rapply(c,r) for r in rs][-1]\n\n# default position a,b,c -&gt; r,f,o, respectively\nassert([\n    rotors('A'),\n    rotors('B'),\n    rotors('C')\n] == ['R','F','O'])\n\n# shift letter `c` forward `n` letters in alphabet\nnshift = lambda c, n : chr((ord(c) - A + n) % NC + A)\n\n# allow rotor rotations\n    # fast spins every letter\n    # medi spins every time fast loops back NC-&gt;0\n    # slow \"\"               medi \"\"\nshifts = lambda l, n : [\n    l % NC, l // NC % NC, l // (NC*NC) % NC,\n    0,\n    l // (NC*NC) % NC, l // NC % NC, l % NC\n][n]\n\n# combine shift apply? don't know what to call\nshiply = lambda c, n, r : nshift(rapply(nshift(c,n),r),-n)\n# or if you prefer\nshiply = lambda c, n, r : chr((ord(r[(ord(c)-A+n)%NC])-A-n)%NC+A)\n\n# single letter enigma, with number of previous letters `l`\nletter = lambda c, l : [c := shiply(c,shifts(l,i),rs[i]) for i in range(len(rs))][-1]\n\n# phrase\n    # enigma starts with an single rotation before first encryption.\nenigma = lambda s : \"\".join([letter(s[i],i+1) for i in range(len(s))])\n\n# test\nassert([\n    enigma(\"AAA\"),\n    enigma(\"ABC\"),\n    enigma(\"ZLC\")\n] == [\"ZLC\",\"ZRA\",\"AAA\"])\n\nif __name__ == \"__main__\":\n    import sys\n    print(enigma(sys.argv[1]))\n\nHere is an example of how it is used to print “HELLOWORLD”:\n\npython3 enigma.py MNBOASVTTB\n\n\n\nVisual Show\n\n\nSingle Cipher\n\nVisualize a cipher as mapping a A-Z to A-Z.\n\nSay, ‘E’ becomes ‘J’\n\n\n      E\n _____|______________________\n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n[     |                      ]  \n[ BDFHJLCPRTXVZNYEIWGAKMUSQO ] # cipher\n ‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n      J\n\n\nIterative Cipher\n\nWe can apply ciphers iteratively.\n\nSo the output ‘J’ of the first cipher is input to the next cipher.\n\n\n ____________________________\n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n[     |                      ]  \n[ BDFHJLCPRTXVZNYEIWGAKMUSQO ] # cipher[0]\n ‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n      J&gt;&gt;&gt;&gt;J               \n __________|_________________\n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n[          |                 ]  \n[ AJDKSIRUXBLHWTMCQGZNPYFVOE ] # cipher[1]\n ‾‾‾‾‾‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n           B\n\n\nAll Ciphers\n\nEnigma ciphers/rotors are named:\n\nFast\nMedium\nSlow\nReflect, which has special properties\n\n\n      E\n _____|______________________\n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n[     |                      ]  \n[ BDFHJLCPRTXVZNYEIWGAKMUSQO ] # fast\n ‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n      J&gt;&gt;&gt;&gt;J               \n __________|_________________\n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n[          |                 ]  \n[ AJDKSIRUXBLHWTMCQGZNPYFVOE ] # medium\n ‾‾‾‾‾‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n   B&lt;&lt;&lt;&lt;&lt;&lt;&lt;B\n __|_________________________\n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n[  |                         ]\n[ EKMFLGDQVZNTOWYHXUSPAIBRCJ ] # slow\n ‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n   K&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;K\n ___________|________________\n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n[           |                ]\n[ IXUHFEZDAOMTKQJWNSRLCYPBVG ] # reflect\n ‾‾‾‾‾‾‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n            M\n\nReflector\n\nWe note that with the reflector:\n\nIf we take the alphabet and find a corresponding letter in the cipher, or\nIf we take the cipher and find a corresponding letter in the alphabet\nWe get the same letter…\n\nThis is…\n\nThe special property of the reflector, and\nHow we will re-use the fast, medium, and slow ciphers.\n\n\n\n\n            K\n ___________|________________\n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n[           |                ]\n[ IXUHFEZDAOMTKQJWNSRLCYPBVG ] # reflect\n ‾‾‾‾‾‾‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n            M\n\n              K\n _____________|______________\n[ IXUHFEZDAOMTKQJWNSRLCYPBVG ] # reflect\n[             |              ]\n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n ‾‾‾‾‾‾‾‾‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n              M\n\n\n\n\n\nDecryption\n\nAfter the reflect cipher, values are decrypted\n\nA letter’s place in the cipher, not alphabet, is found\nThis location is used to determined the letter in the alphabet\nEssentially, a change from mapping the alphabet to a cipher, to vice versa.\n\n‘H’ comes out of the reflector\n\n‘H’ is is index 7 letter of the alphabet\nSo in the next cipher, we’ll look up the index 7 letter of the cipher\nIt is now more helpful to think of an index than a letter - that is what changes here.\n\n\n            K\n ___________|________________\n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n[           |                ]\n[ IXUHFEZDAOMTKQJWNSRLCYPBVG ] # reflect\n ‾‾‾‾‾‾‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n    M&lt;&lt;&lt;&lt;&lt;&lt;&lt;M\n ___|________________________\n[ EKMFLGDQVZNTOWYHXUSPAIBRCJ ] # slow\n[   |                        ]\n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n ‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n    M\n\n\nInversion\n\nWe can separately calculate what cipher would correspond to the “inverted” slow cipher.\n\nWe take all the slow-&gt;alphabet pairs\nWe alphabetize the pairs by the first letter\nThe output is no longer alphabetized, as is a new cipher.\n\nIt is left to the student as a design decision whether do\n\n“Decrypt” via a provided cipher, or\n“Invert” a provided cipher, and apply the inverted cipher.\n\nStudents should consider the complexity of both methods.\n\n\n\n    M\n ___|________________________\n[ EKMFLGDQVZNTOWYHXUSPAIBRCJ ] # slow\n[   |                        ]\n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n ‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n    M\n\n              M\n _____________|______________\n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n[             |              ]\n[ UWYGADFPVZBECKMTHXSLRINQOJ ] # slow^-1\n ‾‾‾‾‾‾‾‾‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n              C\n\n\n\n\nIterating Back\n\nThe next cipher is “medium” and its index 7 letter is ‘U’\n\n‘U’ is the index 20 letter of the alphabet.\n\n\n\n\n    M\n ___|________________________\n[ EKMFLGDQVZNTOWYHXUSPAIBRCJ ] # slow\n[   |                        ]\n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n ‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n    C&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;C\n ________________|____________\n[ AJDKSIRUXBLHWTMCQGZNPYFVOE ] # medium\n[                |           ]  \n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾\n                 P\n\n              M\n _____________|______________\n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n[             |              ]\n[ UWYGADFPVZBECKMTHXSLRINQOJ ] # slow^-1\n ‾‾‾‾‾‾‾‾‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n    C&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;C\n ___|________________________\n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n[   |                        ]  \n[ AJPCZWRLFBDKOTYUQGENHXMIVS ] # medium^-1\n ‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n    P            \n\n\n\n\nEnd-to-end\n\nThe entire end-to-end cipher application can be visualized as follows…\n\n\n\n      E\n _____|______________________\n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n[     |                      ]  \n[ BDFHJLCPRTXVZNYEIWGAKMUSQO ] # fast\n ‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n      J&gt;&gt;&gt;&gt;J               \n __________|_________________\n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n[          |                 ]  \n[ AJDKSIRUXBLHWTMCQGZNPYFVOE ] # medium\n ‾‾‾‾‾‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n   B&lt;&lt;&lt;&lt;&lt;&lt;&lt;B\n __|_________________________\n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n[  |                         ]\n[ EKMFLGDQVZNTOWYHXUSPAIBRCJ ] # slow\n ‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n   K&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;K\n ___________|________________\n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n[           |                ]\n[ IXUHFEZDAOMTKQJWNSRLCYPBVG ] # reflect\n ‾‾‾‾‾‾‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n    M&lt;&lt;&lt;&lt;&lt;&lt;&lt;M\n ___|________________________\n[ EKMFLGDQVZNTOWYHXUSPAIBRCJ ] # slow\n[   |                        ]\n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n ‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n    C&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;C\n ________________|____________\n[ AJDKSIRUXBLHWTMCQGZNPYFVOE ] # medium\n[                |           ]  \n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾\n         P&lt;&lt;&lt;&lt;&lt;&lt;&lt;P\n ________|___________________\n[ BDFHJLCPRTXVZNYEIWGAKMUSQO ] # fast\n[        |                   ]  \n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n ‾‾‾‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n         H\n\n      E\n _____|______________________\n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n[     |                      ]  \n[ BDFHJLCPRTXVZNYEIWGAKMUSQO ] # fast\n ‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n      J&gt;&gt;&gt;&gt;J               \n __________|_________________\n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n[          |                 ]  \n[ AJDKSIRUXBLHWTMCQGZNPYFVOE ] # medium\n ‾‾‾‾‾‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n   B&lt;&lt;&lt;&lt;&lt;&lt;&lt;B\n __|_________________________\n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n[  |                         ]\n[ EKMFLGDQVZNTOWYHXUSPAIBRCJ ] # slow\n ‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n   K&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;K\n ___________|________________\n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n[           |                ]\n[ IXUHFEZDAOMTKQJWNSRLCYPBVG ] # reflect\n ‾‾‾‾‾‾‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n            M&gt;M\n _____________|______________\n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n[             |              ]\n[ UWYGADFPVZBECKMTHXSLRINQOJ ] # slow^-1\n ‾‾‾‾‾‾‾‾‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n    C&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;C\n ___|________________________\n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n[   |                        ]  \n[ AJPCZWRLFBDKOTYUQGENHXMIVS ] # medium^-1\n ‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n    P&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;P    \n ________________|___________\n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n[                |           ]  \n[ TAGBPCSDQEUFVNZHYIXJWLRKOM ] # fast^-1\n ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾\n                 H\n\n\nFor the remainder of the write-up, I will assume without loss of generality the usage of inverted ciphers.\n\n\n\n\nRotors Show\n\n\nSingle Rotor\n\nVisualize a rotor as mapping a A-Z to A-Z.\n\nSay, ‘E’ becomes ‘J’\n\n\n      E\n _____|______________________\n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n[     |                      ]  \n[ BDFHJLCPRTXVZNYEIWGAKMUSQO ] # cipher\n ‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n      J\n\n\nRotation\n\nWe call these things rotors because they rotate:\n\nThe mapping from e.g. index i of the input to index j of the output is unalterated\n\nFor example, ‘E’ is index 5 and maps to ‘J’` at index 10, both of the alphabet\n\nHowever, we can change the rotors as follows:\n\nThe input index is shifted forward by some shift value n\nThis input index is mapped to an output index\nThis output index is shifted backward by the same n\n\n\nLet’s visualize with n = 3\n\n      E\n      |&gt;&gt;&gt;\n      EFGH\n      &gt;&gt;&gt;|\n ________|___________________\n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n[        |                   ]  \n[ BDFHJLCPRTXVZNYEIWGAKMUSQO ] # cipher\n ‾‾‾‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n         P\n      &lt;&lt;&lt;|\n      MNOP \n      |&lt;&lt;&lt;\n      M\n\n\nAs ciphers\n\nIt is worth noting this identical to generating ciphers that start an the index n letter of the alphabet and wrap around from Z to A.\n\n\n\n      E\n      |\n      |&gt;&gt;&gt;\n      EFGH\n      &gt;&gt;&gt;|\n         |\n         |\n ________|___________________\n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n[        |                   ]  \n[ BDFHJLCPRTXVZNYEIWGAKMUSQO ] # cipher\n ‾‾‾‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n         P\n         |\n      &lt;&lt;&lt;|\n      MNOP \n      |&lt;&lt;&lt;\n      |\n      M\n\n      E\n _____|______________________\n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n[     |                      ]  \n[ DEFGHIJKLMNOPQRSTUVWXYZABC ] # forward(3)\n ‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n      H&gt;&gt;H\n ________|___________________\n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n[        |                   ]  \n[ BDFHJLCPRTXVZNYEIWGAKMUSQO ] # cipher\n ‾‾‾‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n         P&gt;&gt;&gt;&gt;&gt;&gt;&gt;P\n ________________|___________\n[ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n[                |           ]  \n[ XYZABCDEFGHIJKLMNOPQRSTUVW ] # forward(-3)\n ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾\n                 M\n\n\nFor the remainder of the write-up, I will assume without loss of generality that rotations can be understood without considering them to be ciphers.\n\n\nFor Enigma\n\nThe Enigma machine triggers rotor rotations every time a letter is encrypted.\nThey rotate as follows\n\nBefore a letter is encryped, the fast rotor rotates forward once.\n\nSo before the first encryption,\n\n(n = 0 : A-&gt;A) becomes (n = 1 : A-&gt;B) before the fast rotor.\n\nTo understand this, the rotation must be applied at two points:\n\nBefore and after going through the fast rotor, and\nBefore and after reversing through the fast^-1 rotor.\n\n\nIf the fast rotor “loops back” from a rotation from (n = 25 : A-&gt;Z) to a non-rotation of (n = 26 = 0 : A-&gt;A).\n\nThe medium rotor advances once, from e.g. (n = 0 : A-&gt;A) to (n = 1 : A-&gt;B)\n\nWhen medium loops back, fast advances once.\nThere are no rotations related to the reflector.\n\nWe image we have typed 29 letters:\n\nthe fast rotor has progressed 29 times and progresses once more before encryption.\n\nSo shift by n = 30, or n = 30-26 = 4.\n\nthe medium rotor progresed 1 time,\nand slow rotor progressed not at all.\n\nSteps labelled “adjust” are not computational\n\nI change horizontal alignment of letters to align the rotors.\nThis is a visual change only, as it was in “Visual” above.\n\n\n     X\n     |\n=====|===========================================\n=    X                                          =\n=    |&gt;&gt;&gt;&gt;                                      =\n=    XYZAB                           # rotate   =\n=    &gt;&gt;&gt;&gt;|                                      =\n=        B                                      =\n=      __|_________________________             =\n=     [ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet = \n=     [  |                         ]            = # fast\n=     [ BDFHJLCPRTXVZNYEIWGAKMUSQO ] # fast     =\n=      ‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾             =\n=        D                                      =\n=    &lt;&lt;&lt;&lt;|                                      =\n=    ZABCD                           # rotate   =\n=    |&lt;&lt;&lt;&lt;                                      =\n=    Z                                          =\n=====|===========================================\n     |\n     Z&gt;Z                             # adjust\n       |\n=======|=========================================\n=      Z                                        =\n=      |&gt;                                       =\n=      ZA                            # rotate   =\n=      &gt;|                                       =\n=       A                                       =\n=      _|__________________________             =\n=     [ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet =\n=     [ |                          ]            = # medium\n=     [ AJDKSIRUXBLHWTMCQGZNPYFVOE ] # medium   =\n=      ‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾             =\n=       A                                       =\n=      &lt;|                                       =\n=      ZA                            # rotate   =\n=      |&lt;                                       =\n=      Z                                        =\n=======|=========================================\n       |\n       Z&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;Z   # adjust\n                                 |\n=================================|===============\n=                                Z              =\n=                                |              =\n=                                Z   # rotate   =\n=                                |              =\n=                                Z              =\n=      __________________________|_             =\n=     [ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet =\n=     [                          | ]            = # slow\n=     [ EKMFLGDQVZNTOWYHXUSPAIBRCJ ] # slow     =\n=      ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|‾             =\n=                                J              =\n=                                |              =\n=                                J   # rotate   =\n=                                |              =\n=                                J              =\n=================================|===============\n                                 |\n                 J&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;J   # adjust\n       __________|_________________\n      [ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet\n      [          |                 ]              # reflect\n      [ IXUHFEZDAOMTKQJWNSRLCYPBVG ] # reflect\n       ‾‾‾‾‾‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n                 O&gt;&gt;&gt;&gt;O              # adjust\n                      |\n======================|==========================\n=                     O                         =\n=                     |                         =\n=                     O              # rotate   =\n=                     |                         =\n=                     O                         =\n=      _______________|____________             =\n=     [ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet =\n=     [               |            ]            = # slow\n=     [ UWYGADFPVZBECKMTHXSLRINQOJ ] # slow^-1  =\n=      ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾             =\n=                     M                         =\n=                     |                         =\n=                     M              # rotate   =\n=                     |                         =\n=                     M                         =\n======================|==========================\n                      |\n                    M&lt;M              # adjust\n                    |\n====================|=============================\n=                   M                           =\n=                   |&gt;                          =\n=                   MN               # rotate   =\n=                   &gt;|                          =\n=                    N                          =\n=      ______________|_____________             =\n=     [ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet =\n=     [ |            |             ]            = # medium\n=     [ AJPCZWRLFBDKOTYUQGENHXMIVS ] # medium^-1=\n=      ‾‾‾‾‾‾‾‾‾‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾             =\n=                    T                          =\n=                   &lt;|                          =\n=                   ST               # rotate   =\n=                   |&lt;                          =\n=                   S                           =\n====================|============================\n                    |\n                    S&gt;&gt;&gt;&gt;&gt;S\n                          |\n==========================|======================\n=                         |                     =\n=                         S                     =\n=                         |&gt;&gt;&gt;&gt;      # rotate   =\n=                         STUVW                 =\n=                         &gt;&gt;&gt;&gt;|                 =\n=      _______________________|____             =\n=     [ ABCDEFGHIJKLMNOPQRSTUVWXYZ ] # alphabet = \n=     [                       |    ]            = # fast\n=     [ TAGBPCSDQEUFVNZHYIXJWLRKOM ] # fast^-1  =\n=      ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|‾‾‾‾             =\n=                             R                 =\n=                         &lt;&lt;&lt;&lt;|                 =\n=                         NOPQR       # rotate  =\n=                         |&lt;&lt;&lt;&lt;                 =\n=                         N                     =\n==========================|======================\n                          |\n                          N\n\n\n\n\nchar * Show\n\n\nHello, world!\n\nI start “enigma.c” with “hello.c” from Alpine\n\nThis file will successfully create an executable, not correctly encrypt or decrypt.\nTry it out with the autograder container.\n\n\n\n\nenigma.c\n\n#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"hello, world\\n\");\n    return 0 ;\n}\n\n\n\nNo strings attached\n\nIn C there are no strings.\n\nThere are instead things called char *\nSay “character star”\nWe attach the * to the variable name\n\nWe’ll revisit this latter - it will make sense.\n\nThat is, an array, or buffer, of characters\n\nNot quite a list - closer to a NumPy array.\n\n\nIt matters what things are called.\n\nIn C we must say what kind of thing a variable is when we “declare” the variable.\nLatter we use the variable, without specifying the kind of thing\nBut we cannot change its kind.\nC variable declaration is like Python function declaration, with def\n\nWe will use format print and variable declarations to introduce “char *”\n\nWe note that Python print appends a newline and C printf does not.\n\nI specify an non-newline terminator in Python for equivalence.\n\n\n\n\n\n\n\ntest.py\n\nx = 1\nprint(f\"{x:d}\", end=\"\")\n# we can reassign x and change its type\nx = \"hello world\"\nprint(f\"{x:s}\", end=\"\")\n\n\n\n\ntest.c\n\nint n = 1;\nprintf(\"%d\", n) ;\n/* we have to make a new variable of novel type */\nchar *m = \"hello world\";\nprintf(\"%s\", m) ;\n\n\n\n\nBoth have the same output:\n\nThe numerical value “1” and the string value “hello world” on the same line.\n\n\n1hello world\n\nYou can update “hello.c” to use a format print.\n\nThis will form the basis of output in this assignment.\n\n\n\n\nenigma.c\n\n#include &lt;stdio.h&gt;\n\nint main() {\n    char *str = \"hello, world\";\n    printf(\"%s\\n\", str);\n    return 0 ;\n}\n\n\n\nConstants\n\nThe C language has a formal support for constants\n\nThese are values that a fixed when the executable is created.\nThey may not be reassigned by any line of code.\n\nThe #define “pre-processor directive” is used to create constants.\n\n#define is like #include which is somewhat like import\nIt defines new values, which are not variables, for use in the .c file\nThe pre-processor reads .c files before the executable is created.\n\nWe can also use #define for strings, such as the rotor strings.\n\nBy convention, constants, are named in all caps, like ROTORS\nI used a single string of all rotors concatenated.\nYou may do whatever works for you.\n\n\n\n\nenigma.c\n\n#include &lt;stdio.h&gt;\n\n#define STR \"hello, world\"\n\nint main() {\n    printf(\"%s\\n\", STR);\n    return 0 ;\n}\n\n\nAn astute learner will note that constants need not be computed within an executable.\nIt is not uncommon to compute constants in a different file, or even in a different language.\n\nMy ROTORS constant was computed in Python.\nI used Python file operations to save this computation to “enigma.c”\nVia vim I used the “yank” and “paste” features to move it to the top of “enigma.c”.\n\n\n\n\nJust a little bit\n\nIn C, characters aren’t printing characters.\n\nThey are “just bits” - a collection of ones and zeroes, or a number.\nWe attach the * to the variable name\n\nWe’ll revisit this latter - it will make sense.\n\nThis differs from Python, which uses strings of length one.\n\nThis is sketchy, sometimes.\nStrings are a non-numeric.\n\n\nIf we want to use a numerical value as a printing character, we use a format print.\nC characters use single quotes, and C strings use double quotes.\n\n\n\n\n\ntest.py\n\nx = ord('A')\nprint(f\"{x:d}, {x:x}, {x:c}\")\n\n\n\n\ntest.c\n\n/* We do not use anything like ord() */\nprintf(\"%d, %x, %c\\n\", 'A','A','A');\n\n\n\n\nBoth have the same output:\n\nThe decimal (base 10), hexadecimal (base 16), and unicode/ascii representations of the same value.\n\n\n65, 41, A\n\nAn astute learner will note that this insight is sufficient to implement a rotor.\n\n\n\n\n\nC loop Show\n\n\nBuilding Character\n\nThe core complication of the Enigma machine was that it was an iterative cipher.\nLet’s practice iteration by iterating over a char *\nWe note:\n\nIn C there is no string, list, tuple, generator, dictionary, or set type.\nIn Python, for loops require one of these types.\nHenceforth we refer to the C for loop as a “for loop” and Python for loop as a “for each loop”.\n\nA for loop is composed of three components:\n\nInitiate\nTerminate\nIterate\n\nSyntactically, they are structured follows:\n\nfor ( 𝘪𝘯𝘪𝘵𝘪𝘢𝘵𝘦; 𝘵𝘦𝘳𝘮𝘪𝘯𝘢𝘵𝘦; 𝘪𝘵𝘦𝘳𝘢𝘵𝘦) { \n    𝘤𝘰𝘥𝘦 𝘣𝘭𝘰𝘤𝘬\n}\n\nPrint 0 through 9\n\nint i ;\nfor ( i = 0; i &lt; 10; i++) { \n    printf(\"%d\\n\", i);\n}\n\nWe now explore each component.\nAn astute learner will note that this insight is sufficient to implement the entire enigma machine.\n\nRemaining headings provide guidance on common pitfalls.\nIf you can do enigma now, skip to “C args”\n\n\n\nIterate\n\nThe last of the three for loop components, the iterator, is closest to the Python for each loop.\nThe iterator statement is run each time the loop completes, after the internal code block is run.\nAny statement may be placed in this position.\nThe most common is i++, a special shorthand for incrementation.\n\nIt is logically equivalent to Python i += 1.\n\nFind the length of the first word in a string with an iterator only:\n\nIncrease a string index by one within the iterator.\nInclude an if statement in the for loop code block.\nUse a return statement in the if statement code block.\n\n\nchar *str = \"hello world\";\nint i = 0;\nfor ( ; ; i++) {\n        if (str[i] == ' ') {\n                printf(\"%d\\n\", i);\n                return 0;\n        }\n}\n\n\nTerminate\n\nUnlike Python strings, C character arrays have no length.\nRather, they end with a special character.\n\nThis character is called the null terminator\nIt is non-printing (not visible).\nIt is denoted explicitly via '\\0'\n\nSingle quotes to denote a character.\nA backslash “escape” character to denote a special character.\nA zero to denote it is “null”, “zero”, or “nothing”\n\nIt is numerically equal to zero.\n\nUnlike Python booleans, C has no boolean type.\n\nRather it has truthiness, akin to Python if statements with numerical conditions.\nThe numerical value zero is false.\nAll other numerical values are true.\n\nThe termination statement causes the loop to end when it is equal to zero.\nFind the length of the first word in a string with a terminator only:\n\nCheck if a character is the null terminator in the termination statement.\nInclude an incrementation in the for loop code block.\n\n\nchar *str = \"hello world\";\nint i = 0;\nfor ( ; str[i] ; ) {\n        i++;\n}\nprintf(\"%d\\n\", i);\nreturn 0;\n\nThis is also a good example of how sometimes the C for loop may have no code block.\n\nHere is a logically equivalent way to measure the length of a char * serving as a string.\n\n\nchar *str = \"hello world\";\nint i = 0;\nfor ( ; str[i] ; i++ ) { }\nprintf(\"%d\\n\", i);\nreturn 0;\n\nThis is also a good chance to test what order the terminator and iterator are checked.\n\nThe terminator is checked before the iterator.\nThe iterator does not if the terminator is true.\n\nThis matters a lot in this case, where the length calculated would be off by one.\n\n12 instead of 11\nThe value of the iteration variable i is increased the same time the terminator is checked.\nSo the null terminator is at index 11 but this C code would print the numerical value 12.\n\n\nchar *str = \"hello world\";\nint i = 0;\nfor ( ; str[i++] ; ) { }\nprintf(\"%d\\n\", i);\nreturn 0;\n\n\nInitiate\n\nThe initiator allows setting a variable to a certain value before beginning a loop.\nI mostly use it when I have more than one loop, and want to use i for both.\nHere is the above example, with an iniatiator.\n\nchar *str = \"hello world\";\nint i ;\nfor ( i = 0; str[i++] ; ) { }\nprintf(\"%d\\n\", i);\nreturn 0;\n\nThe following is permissable in all modern forms of C, but was not an initial feature of the language.\n\nAs a rule, I try not to declare variables in the initializer so my code works on older devices.\nIt also makes writing a C compiler easier, if you ever plan to do that.\n\n\nchar *str = \"hello world\";\nfor ( int i = 0; str[i++] ; ) { }\nprintf(\"%d\\n\", i);\nreturn 0;\n\n\n\n\n\nArrays Show\n\n\nCollections\n\nC lacks any collection type (list, set, tuple, string)\n\nnotation is used instead\n\ndenotes the location of a some value\n\nThe type of this value gives its size\nSuccessive values are at successive locations\nThese are memory address.\n\n[] notation may also be used\n\nWe simply include the length within brackets.\n\nWe don’t worry about any of that for now.\nYou will likely want to use a collection on Enigma:\n\nRotor rotations\nRotors themselves\nI don’t know, for fun.\n\nC array notation is very similar to Python set notation, but maintains order\n\nYou are responsible for keeping track of the length.\n\n\nchar carray[5] = {'a', 'e', 'i', 'o', 'u'};\nint iarray[5] = {2, 4, 8, 16, 32};\nint i;\nfor (i = 0; i &lt; 5; i++) {\n    printf(\"%c %d\\n\", carray[i], iarray[i]);\n}\n\nCharacter arrays\n\nUnlike Python, where a list of characters and a string of characters differ.\nIn C, an array of characters and a “string” of characters are identical.\n\nchar carray[5] = {'a', 'e', 'i', 'o', 'u'};\nchar string[5] = \"abcde\";\nint i;\nfor (i = 0; i &lt; 5; i++) {\n        printf(\"%c %c\\n\", carray[i], string[i]);\n}\n\nC strings are implicitly null terminated, so there is a minor difference, but that is immaterial here.\n\nHow would you check if a string is null terminated?\n\n\n\n\n\n\n\nC math Show\n\n\nInteger Division\n\nIn C, there are numerous integer data types, including int and char\nAll use integer division by default.\nTest as follows:\n\nint i;\nfor (i = 0; i &lt; 5; i++) {\n        printf(\"%d / %d -&gt; %d\\n\", i, 2, i / 2);\n}\n\nThe results are clear:\n\n0 / 2 -&gt; 0\n1 / 2 -&gt; 0\n2 / 2 -&gt; 1\n3 / 2 -&gt; 1\n4 / 2 -&gt; 2\n\n\nModulo\n\nBoth C and Python have a % operator\n\nIn Python it is the “more mathematical correct” modulo operation\nIn C it is the less common remainder operation.\n\nThe differences were non-obvious and led to a pernicious bug in my enigma.c\n\n\nPython %\n\nFirst, test Python\n\n\n\nmodulo.py\n\n[print(f\"{i:2d} % 3 -&gt; {i%3:d}\") for i in range(-5,5)]\n\n\nWe see the predictable result.\n\n-5 % 3 -&gt; 1\n-4 % 3 -&gt; 2\n-3 % 3 -&gt; 0\n-2 % 3 -&gt; 1\n-1 % 3 -&gt; 2\n 0 % 3 -&gt; 0\n 1 % 3 -&gt; 1\n 2 % 3 -&gt; 2\n 3 % 3 -&gt; 0\n 4 % 3 -&gt; 1\n\n\nC %\n\nNow, test C\n\n\n\nremainder.c\n\n#include &lt;stdio.h&gt;\n\nint main() {\n        int i;\n        for (i = -5; i != 5; i++) {\n                printf(\"%2d %% %d -&gt; %2d\\n\", i, 3, i % 3);\n        }\n        return 0;\n}\n\n\nWe see the predictable result.\n\n-5 % 3 -&gt; -2\n-4 % 3 -&gt; -1\n-3 % 3 -&gt;  0\n-2 % 3 -&gt; -2\n-1 % 3 -&gt; -1\n 0 % 3 -&gt;  0\n 1 % 3 -&gt;  1\n 2 % 3 -&gt;  2\n 3 % 3 -&gt;  0\n 4 % 3 -&gt;  1\n\nUnlike Python, C % may generate negative results.\nThere are a number of ways to deal with that.\n\n\n\nPythonic % in C\n\nWith thanks to Stack Overflow\n\nprintf(\"%2d Py%% %d -&gt; %d\\n\", i, 3, ((i % 3) + 3) % 3);\n\nThis gives necessarily positive values.\n\n-5 Py% 3 -&gt; 1\n-4 Py% 3 -&gt; 2\n-3 Py% 3 -&gt; 0\n-2 Py% 3 -&gt; 1\n-1 Py% 3 -&gt; 2\n 0 Py% 3 -&gt; 0\n 1 Py% 3 -&gt; 1\n 2 Py% 3 -&gt; 2\n 3 Py% 3 -&gt; 0\n 4 Py% 3 -&gt; 1\n\n\n\n\n\nC args Show\n\n\nArguments\n\nThe reference Python contains the following snippet:\n\nif __name__ == \"__main__\":\n    import sys\n    print(enigma(sys.argv[1]))\n\nThis is roughly equivalent to printing the return result of the enigma function within a function called main.\nThis is close to C, but we don’t haven’t introduced a way to use command line arguments.\nLet’s look at a minimal Python example.\n\n\nPyEcho\n\n\npyecho.py\n\nimport sys\nprint(sys.argv[1])\n\n\nWe use as follows:\n\npython3 pyecho.py \"hello world\"\n\nWe can construct the same within C.\n\n\n\nCEcho\n\nThe Python sys module contains many features present by default in a systems programming language.\nOne such is argv, a vector (in the mathematical sense) of arguments.\n\nThese are command line arguments.\nIn Python a list of strings\nIn C an array of char *\nThe zeroth argument is the name of the Python script or C executable\n\nThere is additionally something called argc, an integer count of arguments.\n\nIn C this is needed to know the length of the vector\nIn Python it is redundant, but potentially useful\n\nWe have thus far written main with no arguments, so we also introduce how to write functions with arguments.\n\nC function arguments are identical to Python function arguments\nAs with other variables, C function argument variables must be declared with a type\nUsing functions will make writing C much easier.\n\n\n\n\ncecho.c\n\n#include &lt;stdio.h&gt;\n\nint main(int argc, char **argv) {\n        printf(\"%s\\n\", argv[1]);\n        return 0;\n}\n\n\nYou may wish to compile then try the following:\n\ngcc cecho.c -o cecho\n\nNo arguments, which gives a segmentation fault, a type of error when you try to read something that doesn’t exist\n\n./cecho\n\nOne argument, which is printed.\n\n./cecho hello\n\nTwo argument, of which one is printed.\n\n./cecho hello world\n\nTwo words as a single argument using quotes.\n\n./cecho \"hello world\"\n\nYou may note that Python has all the same features.\n\n\n\n\n\n\nTester Show\n\n\nPodman\n\nI am providing the following Containerfile, which will serve as a minimal autograder\n\nIt sets up an Alpine container.\nIt downloads a Python script to test.\nIt copies in “enigma.c” from your system.\n\n\n\n\nContainerfile\n\nFROM alpine\n\nRUN apk add gcc libc-dev python3 curl\n\nRUN curl https://raw.githubusercontent.com/cd-c89/crypto/main/enigma/tester.py -o tester.py\n\nCOPY enigma.c .\n\n\n\nUsage\n\nI built my container via:\n\npodman build -t tester .\n\nI tested my code via:\n\npodman run tester python3 tester.py\n\nIf the above script returns “Perfect!” you are done.\n\nCreate a Gist with an “enigma.c”.\nEmail me the url of your Gist, it will look something like, from your official school email:\n\n\nhttps://gist.github.com/cd-public/a840e95e71ac7309a53ab0bb1282ba40\n\nI will review the most recent version prior to the due date.\n\n\n\nVim trick:\n\nYou will probably want to work in a container with vim and also test your code in the same container.\n\nIt is possible to create a second command line tab that is also within the container.\n\nConsult podman documentation - many ways to do this.\n\nI recommend using vim built-in :term command, which splits the screen into a vim editor and a vim terminal.\nYou can move between windows using ctrl+w - if it doesn’t work, Google it.\n\n\n\n\nPodman trick:\n\nYou will probably want to create one container then work in that container until you finish.\npodman run will create a new container each time, which is not what you probably want.\nThe following recycles the previous container, mostly.\n\nRead more: Stack Overflow\n\n\npodman start -a -i `podman ps -q -l`"
  },
  {
    "objectID": "podman.html#kennedy-is-my-middle-name",
    "href": "podman.html#kennedy-is-my-middle-name",
    "title": "Podman",
    "section": "Kennedy is my middle name",
    "text": "Kennedy is my middle name\n\nNot an endorsement; I voted for ******* **** ****** ********!"
  },
  {
    "objectID": "sha256.html#compression-operations",
    "href": "sha256.html#compression-operations",
    "title": "SHA256",
    "section": "Compression Operations",
    "text": "Compression Operations\n\nWe divide into unary, binary, and trenary bitwise logical operations, and shift/rotate operations.\nBitwise logical operations work over 1, 2, or 3 words of size 32 (uint32_t)\n\nTerm these, \\(U\\), \\(V\\), \\(W\\)\n\nThe first is complement, negation, or not:\n\\(\\lnot U\\): bitwise complement\nThere is no graceful Python implementation.\n\nuint32_t complement(uint32_t u) {\n    return ~u ;\n}\n\n\\(U \\land V\\), \\(U \\lor V\\), \\(U \\oplus V\\): AND, OR, XOR\n\\(SHR_n(U)\\): shift right by \\(n\\)\n\\(ROTR_n(U)\\): rotate right by \\(n\\)\nSpecial functions: \\[\n\\text{Ch}(U, V, W) = (U \\land V) \\oplus (\\lnot U \\land W)\n\\] \\[\n\\text{Maj}(U, V, W) = (U \\land V) \\oplus (U \\land W) \\oplus (V \\land W)\n\\] \\[\n\\Sigma_0(U) = ROTR_2(U) \\oplus ROTR_{13}(U) \\oplus ROTR_{22}(U)\n\\] \\[\n\\Sigma_1(U) = ROTR_6(U) \\oplus ROTR_{11}(U) \\oplus ROTR_{25}(U)\n\\]"
  }
]