---
title: SHA256
author: Prof. Calvin
subtitle: "Week 0x2"
institute: Crypto
format: 
    revealjs: 
        code-fold: false
        theme: dark
        mainfont: monospace
        slide-number: true
        show-slide-number: all
        width: 1050
        height: 700

execute:
    echo: true
    cache: true
    freeze: true  # never re-render during project render
---

# Announcements

- **Welcome** to variously CS 276/CS 540
- **Action Items**:
  - How was Macros?
  - Next homework coming out now - SHAinC

# Today

- SHA256
    -   Why?
    -   What?
    -   How?

# Slide Credit

-   [**Saravanan Vijayakumaran**](https://www.ee.iitb.ac.in/~sarva/)
-   sarva@ee.iitb.ac.in  
-   Department of Electrical Engineering  
-   Indian Institute of Technology Bombay  

# Hash Functions

-   Methods for **deterministically** compress a long input string to a shorter output called a digest
    -   Also called "signature"
    -   Can hash *anything stored in computer*
-   These are also called "compression" or "one-way" hash functions.

# Hash Merits

-   Primary requirement is that it should be infeasible to find collisions, 
    -   i.e. no two inputs have same digest.
    -   If I download Ubuntu and check the signature, I should know it's Ubuntu.
    -   If Ubuntu and a malware package have the same signature, useless.

# Non-Cryptographic

-   Used to build **<strong>**hash tables**</strong>** 
    -   Key-value stores with $\mathcal{O}(1)$ lookup time. 
    -   [My hashtable/hashmap slides](https://cd-public.github.io/slide_portable/hashmap.html#/title-slide)
-   Example: Python `hash`
```{python}
print("\n".join([f"{hash(a):+d}" for a in "ABCDE"]))
```

# Example.tex

-   Let $M$ be the size of some hash table
-   Take $a, W \in \mathbb{N} : W < M \land \gcd(a, W) = 1$
    -   That is, two positive coprime integers.
-   Any integer value $x$ can be mapped into $\mathbb{N}_M = \{0,1,\ldots, M-1\}$
    
```LaTeX
h_a(x) = \left\lfloor \frac{a x \bmod W}{W} M \right\rfloor
```
$$
h_a(x) = \left\lfloor \frac{a x \bmod W}{W} M \right\rfloor
$$

# Example.py
-   We can express in a programming language.
-   We note that 257 == 0x101 is prime.
    -   And therefore $\forall W : gcd(257,W)$
```{python}
import math
h = lambda x, a, W, M : math.floor(((a * x) % W) / W * M)
a, W, M = 0x101, 1 << 0x10, 1 << 0x08
assert(all((not math.gcd(a, W) == 1) or h(x, a, W, M) in range(M) for x in range(M)))
print('h'+str((0xDA7A,a,W,M)), '=', h(0xDA7A,a,W,M))
```

# Example.c
-   We note a high performance special case.
-   Let $w$ be the bit size used to store numbers
    -   Likely 32 == 0x20 for C `unsigned`
    -   $W$ stands for [word](https://en.wikipedia.org/wiki/Word_(computer_architecture)) size
-   Take $W = 2^w$ and $M = 2^m$

```{.C}
unsigned int h(unsigned int x, unsigned int a, unsigned int m) {
    return (a * x) >> (sizeof(unsigned int) * 0x10 - m); 
}
```

# Collisions

-   A **collision** occurs if
$$
\exists x, x' : x \neq x` \land h(x) = h(x')
$$
-   That is, this assertion *fails*:
```{.py}
assert(((x_0 != x_1) and (h(x_0, a, W, M) == h(x_1, a, W, M)))
```
-   **Goal:** minimize:non-crypto::avoid:crypto collisions.
    -   Achieve this via a large co-domain for $h$

# Codomain:

> ["In mathematics, a codomain or set of destination of a function is a set into which all of the output of the function is constrained to fall. It is the set $Y$ in the notation $f: X → Y$. The term range is sometimes ambiguously used to refer to either the codomain or the image of a function."](https://en.wikipedia.org/wiki/Codomain)

# Test it:

```{python}
h = lambda x, a, W, M : math.floor(((a * x) % W) / W * M)
a, W, M = 0x101, 1 << 0x10, 1 << 0x08
assert(set(h(x, a, W, M) for x in range(M)) == set(range(M)))
```
-   As a rule we shouldn't try to write proofs/definitions in Python, but...
-   Small $W = 2^{0x10} = 65536$ means our computer can handle all possibilities.

# Visualize:

<img style="filter: invert(100%);" src="https://www.ee.iitb.ac.in/~sarva/courses/EE720/2023/slides/images/codomain-256.svg">

# Cryptgraphic

-   Begin with SHA-2 (Secure Hash Algorithm 2).
    -   A family of cryptographic hash functions.
    -   By the [U.S. National Security Agency (NSA)](https://www.youtube.com/watch?v=mJHvSp9AKYg)
-   Published by the U.S. National Institute of Standards and Technology (NIST) in 2001.

# Context
-   SHA-1, released in 1995, found to have significant vulnerabilities.
-   Growing concerns about the security of SHA-1 led to the development of SHA-2.
    -   SHA-3 released in 2015, not in wide use.
    -   For *if* weakness in SHA-2 discovered.
    -   SHA-2 regarded as secure in 2025.

# Family
- Six hash functions release August 2001:
  - SHA-224
  - SHA-256
  - SHA-384
  - SHA-512
  - SHA-512/224
  - SHA-512/256

# Adoption and Usage
-   SHA-2 has been widely adopted in 
    -   Digital signatures
    -   Certificate validation
    -   File integrity verification.
    -   **Blockchain:** 
        -   1 of ~2 core technologies of Bitcoin
        -   SHA-256 specifically

# SHA-2 Pledge

-   I need a verbal confirmation:
    -   Even though we will implement cryptography...
    -   We assume their insecurity as we learn to:
        -   Test our code
        -   Write proofs
        -   Use compilers
    -   We don't know what side channel attacks are.
        -   I say: out-of-scope.

# SHA-256 Overview

- **SHA-2** with a **256-bit output length**
- Accepts bit strings of length up to $2^{64} - 1$
    -   ~20 quintillion bits
    -   ~17 million terabytes

# Two Stages

- Output calculation has two stages:
  1. **Preprocessing**
  2. **Hash Computation**

# Preprocessing

- A 256-bit state variable $H^{(0)}$ is initialized:

\begin{align*}
\begin{split}
   H_0^{(0)} = \texttt{0x6A09E667}, \quad H_1^{(0)} = \texttt{0xBB67AE85},\\
   H_2^{(0)} = \texttt{0x3C6EF372}, \quad H_3^{(0)} = \texttt{0xA54FF53A},\\
   H_4^{(0)} = \texttt{0x510E527F}, \quad H_5^{(0)} = \texttt{0x9B05688C},\\
   H_6^{(0)} = \texttt{0x1F83D9AB}, \quad H_7^{(0)} = \texttt{0x5BE0CD19}.
\end{split}
   \end{align*}

- We'll calculate these in the lab.

# Input Padding

- The input $M$ is padded to a length that is a multiple of 512.

- Let $M$ be $l$-bits long.
- Find the smallest non-negative $k$ such that:
$$
k + l + 65 = 0 \pmod{512}
$$

# Padding Content

- Append $k + l + 65$ bits: 
    -   A single one (`1`), followed by 
    -   $k$ zeros (`0`), followed by
    -   The 64-bit representation of $l$.
$$
\begin{align*}
1\underbrace{000 \cdots 000}_{n \textrm{ zeros}}\underbrace{l}_{\textrm{ 64 bits}} \\
\end{align*}
$$

# Example.py

-   We can solve numerical in Python, but...
-   Perhaps easier to show with strings.
```{python}
k, l = 8, 123
print('String:', '0b1' + '0' * (k) + f"{l:064b}")
```
-   The arithmetic form is left an exercise for the interested student.
    -   My solution was 10-20 characters of code.

# Hash Computation

- Padded input is split into $N$ 512-bit blocks: 
$$
M^{(1)}, M^{(2)}, \ldots, M^{(N)}
$$
- The hash function has the following type:
$$
f: M:\{0,1\}^{512} \times H:\{0,1\}^{256} \rightarrow H':\{0,1\}^{256}
$$
- Given $H(i-1)$, calculate $H(i)$ using:
 $$
 H(i) = f(M^{(i)}, H(i-1)), \quad 1 \leq i \leq N.
 $$


# Words

-   We specify bitwise operations over **exactly** 32 bit words.
-   The industry standard is to use `stdint`
```{.C}
#include <stdint.h>

/* uint32_t is "unsigned integer of size 32 type" */
uint32_t rotate(uint32_t a, uint32_t b) {
    asm("rorl %%cl, %0" : "+r" (a) : "c" (b));
    return a;
}
```

# Operations

- Bitwise logical operations
    -   Unary,
    -   Binary, and
    -   Ternary, and
- Shift/rotate operations
- Operations work over 1, 2, or 3 words of size 32 (uint32_t)
    -   Term these words $U$, $V$, $W$

# Unary Bitwise

- The first is 'bitwise complement', or 
- 'bitwise logical not':
$$
\lnot U
$$
- There is no graceful Python implementation.
```{.C}
uint32_t complement(uint32_t u) {
    return ~u ;
}
```

# Binary Bitwise

- $U \land V$, $U \lor V$, $U \oplus V$: AND, OR, XOR
- $SHR_n(U)$: shift right by $n$
- $ROTR_n(U)$: rotate right by $n$

- **Special functions**:
$$
\text{Ch}(U, V, W) = (U \land V) \oplus (\lnot U \land W)
$$
$$
\text{Maj}(U, V, W) = (U \land V) \oplus (U \land W) \oplus (V \land W)
$$
$$
\Sigma_0(U) = ROTR_2(U) \oplus ROTR_{13}(U) \oplus ROTR_{22}(U)
$$
$$
\Sigma_1(U) = ROTR_6(U) \oplus ROTR_{11}(U) \oplus ROTR_{25}(U)
$$



## Compression Function Calculation

1. **Internal State Initialization**:
 $$
 W_j = 
 \begin{cases} 
 M^{(i)}_j & 0 \leq j \leq 15 \\
 \sigma_1(W_{j-2}) + W_{j-7} + \sigma_0(W_{j-15}) + W_{j-16} & 16 \leq j \leq 63
 \end{cases}
 $$

2. Initialize eight 32-bit words:
 $$
 (A, B, C, D, E, F, G, H) = (H(i-1)_0, \ldots, H(i-1)_7).
 $$

3. Iterate $j = 0$ to $63$:
 $$
 T_1 = H + \Sigma_1(E) + \text{Ch}(E, F, G) + K_j + W_j
 $$
 $$
 T_2 = \Sigma_0(A) + \text{Maj}(A, B, C)
 $$
 $$
 (A, B, C, D, E, F, G, H) = (T_1 + T_2, A, B, C, D + T_1, E, F, G)
 $$

4. Update $H(i)$:
 $$
 H(i)_j = A + H(i-1)_j, \quad j = 0, \ldots, 7
 $$



## The Merkle-Damgård Transform

- **Construction**: Example of MD transform.
- **Purpose**: Extend domain to construct collision-resistant hash functions.



## References

- Chapter 3 of *An Introduction to Bitcoin*, S. Vijayakumaran  
[www.ee.iitb.ac.in/~sarva/bitcoin.html](https://www.ee.iitb.ac.in/~sarva/bitcoin.html)

