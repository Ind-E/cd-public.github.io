---
title: C89/99
theme: dark
author: Prof. Calvin
subtitle: "Week 0x1"
institute: Crypto
format: 
    revealjs: 
        theme: dark
        mainfont: monospace
execute:
  echo: false
---

# Announcements

- **Welcome** to variously CS 276/CS 540
- **Action Items**:
  - Get out our feelings on the Enigma assignment
    - We are learning by doing.
  - Next homework coming out now - Ch/Maj

# Homework

- The first homework, "Enigma", is due when class starts Th of Week 0x1
- The next homework, "Ch/Maj", is ready at any time
  - Fiddling with bits, building on the lab, now in a good language!
  - Applies our learnings from today.
  
# Today

- Reintroduce the technologies
  - `podman`
  - `vim`
  - `gcc`
  - `git`
  
# What is Podman?

- **Definition:**
  - Platform to develop, ship, and run applications in isolated containers.
- **Benefits:**
  - Portability, consistency across environments.
- **Editorializing:**
  - Probably all code should be written in a container now that they exist.

# In practice:

- **Windows** only
  - Run `wsl --install -d ubuntu` command once
- **Windows+Mac:**
  - Use Podman Installer once
  - Launch Podman Desktop each time you code
  - Use `podman` commands
- **Linux:**
  - Have fun with your package manager.


# Podman

- Podman solves the problem of writing code on one computer and running it another.
- Simply specify a Podman image
  - a description of a imaginary computer
- Podman will pretend to be that computer
- We can run code "inside" Podman
  - Code in the container can't tell it's running inside Podman

# Images

- Something we `podman run -it` is an _image_
  - It is a template that correspond to many possible pretend computers
  - I think of them like object oriented class
  - They define something that could be

# Containers

- Each time we run said command, we have a different _container_
  - They have different file systems
  - Things we install don't persist to future `run` instances.
  - I think of them like objects of a class
  - Like '1' instead of 'integer'
  - They are actually existing, running code.

# Reuse

- On Enigma, probably:
  - You opened a container.
  - You wrote some code in vim.
  - You compiled the code.
  - You ran the executable.
  - The executable deorbited a space station. /s
  - You closed the container and went to touch grass.

# Today

- &check; Introduce the course
  - &check; The C Programming Language
  - &check; Cryptography + Cryptocurrency
- Introduce the technologies
  - &check; `podman`
  - `vim`
  - `gcc`
  - `git`

# IDEs

- At some point in time, code started being written in IDEs.
  - Integrated design environments.
  - To me, the first one was Eclipse (for Java)
- VS Code is the ascendent IDE, and is everywhere.
  - Google Cloud has **browser based** VS Code clone
- VS Code has some nice things - including good `git` and `docker` (less so `podman`) integration.
  
  
# Integration

- VS Code has some nice things 
  - Works with `git`/`docker` (less so `podman`).
  - You know what else can do that?
  - The command line
  - Which you don't have to install
- IDEs are ~new, the was command line utilities
  - Vi(m)
  - Emacs
  - Nano
  
# Why Vim?

- While IDEs are ascendent...
  - The are not installed on every system
  - They can be hard to use in cloud
  - They can start costing money at any time
  - They seem slower and to produce worse code
- Like Python, IDEs are easy!
  - This is good for new coders
  - It is a design decision thereafter
  
# Vim

- Vim isn't too bad
  - It can basically be used as a keyboard navigated text editor.
  - It has really good keyboard shortcuts and modes that we learn over time.
  - It seems to be the pound-for-pound productivity champion of all time.
- It is hard to find people who have learned `vim` who don't prefer it.

# Podvim

- We can install and run `vim` inside a container (which happens to run Debian & &there4; `apt`)
- Even directly from Python...
```py
>>> import os
>>> os.system("apt update") # update the registry of packages
<blah blah blah>
>>> os.system("apt install vim -y") # -y saves us from having to say "yes" to any prompts
<blah blah blah>
>>> os.system("vim") # a vim window will open
```
- This is `vim` inside `python` inside `podman`
  - Don't do this, it's a proof-of-concept

# Vim
- It looks like this:
```bash
~               VIM - Vi IMproved
~                  version 9.1
~            by Bram Moolenaar et al.
~   Vim is open source and freely distributable
~
~          Become a registered Vim user!
~  type  :help register<Enter>   for information
~
~  type  :q<Enter>              to exit
~  type  :help<Enter>  or  <F1> for on-line help
~  type  :help version9<Enter>  for version info
```

# Usage

- I usually use vim as `vim filename.py`
  - When `vim` opens I type `i` (for "insert")
  - Then I write code.
  - ESC &rarr; `:x` &rarr; ENTER to save+quit
- Learn `vim` incrementally by using it for this class - for code, for notes, for whatever.


# Today

- &check; Introduce the course
  - &check; The C Programming Language
  - &check; Cryptography + Cryptocurrency
- Introduce the technologies
  - &check; `podman`
  - &check; `vim`
  - `gcc`
  - `git`

# GCC

- Developed for the C language to make an open source operating system in 1987.
- Mainly around today for the C language to make an open source operating system (Linux)
- (The C language was invented to write an operating system).
- `python` is written in GCC C
```python
C:\Users\cd-desk>podman run -it python
Python 3.13.1 (main, Dec  4 2024, 20:40:27) [GCC 12.2.0] on linux
```

# Great freeware

- Many legendary programs created using GCC:
  - HTTPD & NGINX, which serve a majority of webtraffic
  - Every major Linux and FreeBSD distribution
  - Major browsers like Firefox and Chromium
    - Firefox is on `clang` now but that's new
  - GNU Bash and Coreutils, like `cat`, `ls`, `rm`
  - Bitcoin Core
  
# Compilation

- Like `python` or `podman` or `vim`, GCC is a command - `gcc`
- `gcc` takes at least one argument: a filename, usually of a C file
- GCC takes this C file and makes an executable 
  - a program, sort of
- Executables run as command with `./` prefix
  - This differs from `python` which runs a script **without** creating a corresponding program.

# .py vs .c

```{mermaid}
%%| theme: Darkly
flowchart LR
  A(Python) --> B[fname.py file]
  B --> C[python fname.py]
  C --> D{hello world}
  E(C) --> F[fname.c  file]
  F --> G[gcc fname.c -o ename]
  G --> H[./ename]
  H --> I{hello world}
```

- _You only have to compile once to have the executable forever._
- _Most programs are executables, not scripts._

# Today

- &check; Introduce the course
  - &check; The C Programming Language
  - &check; Cryptography + Cryptocurrency
- Introduce the technologies
  - &check; `podman`
  - &check; `vim`
  - &check; `gcc`
  - `git`
  
# Git

<ul>
<li> Git was invented... to store the C language source code for an open source operating system (Linux)</li>
<li> It is de facto the only way in the universe to store code other than "on my HDD/SSD"</li>
<li> It is also a very good way to
    <ul>
    <ol>
    <li> Keep track of podman images</li>
    <li> Keep track of podman containers</li>
    <li> Keep track of code used inside containers</li>
    </ol>
    </ul>
</li>

# As a command

- Git corresponds, like the others, to a command: `git`
  - It is common now to use other techniques, but the command remains extremely **stable**
- Quoth GitHub, the first and greatest of the collaboration tools:

<a href="https://docs.github.com/en/get-started/using-github/connecting-to-github"><blockquote>
If you want a lot of control and flexibility, you can use the command line.
</blockquote></a>